<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.9.8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Munk2D Documentation: Manual</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
    <script
      type="text/javascript"
      src="doxygen-awesome-darkmode-toggle.js"
    ></script>
    <script type="text/javascript">
      DoxygenAwesomeDarkModeToggle.init();
    </script>
    <script
      data-goatcounter="https://munk2d.goatcounter.com/count"
      async
      src="//gc.zgo.at/count.js"
    ></script>
  </head>
  <body>
    <div id="top">
      <!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr style="height: 56px">
              <td id="projectalign" style="padding-left: 0.5em">
                <div id="projectname">
                  Munk2D Documentation
                  &#160;<span id="projectnumber"
                    >8.x.x</span
                  >
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
    </div>
  </body>
</html>
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('guide.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Manual</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><blockquote class="doxtable">
<p>&zwj;[!note] These documents are not yet fully updated to reference Munk2D. Links will still point to Chipmunk2D, the text will still be written where "I" references Slembcke, the creator of Chipmunk2D etc. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md0"></a>
Intro</h1>
<p>Chipmunk2D is a 2D rigid body physics library distributed under the MIT license. It is blazingly fast, portable, numerically stable, and easy to use. For this reason it has been used in hundreds of games across just about every system you can name. This includes top quality titles such as Night Sky for the Wii and many #1 sellers on the iPhone App Store! I've put thousands of hours of work over many years to make Chipmunk2D what it is today. If you find Chipmunk2D has saved you a lot of time, please consider <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=6666552">donating</a>. You'll make an indie game developer very happy!</p>
<p>First of all, I would like to give Erin Catto a big thank you, as Chipmunk2D's impulse solver was directly inspired by his example code way back in 2006. (Now a full-fledged physics engine all its own: <a href="http://www.box2d.org/">Box2D.org</a>). His contact persistence idea allows for stable stacks of objects with very few iterations of the solver. My previous solver produced mushy piles of objects or required a large amount of CPU to operate stably.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Why a C Library?</h2>
<p>A lot of people ask me why I wrote Chipmunk2D in C instead of <em>pick your favorite language here</em>. I tend to get really excited about different programming languages. Depending on the month, take your pick of Scheme, OCaml, Ruby, Objective-C, ooc, Lua, Io... the list goes on. The one common factor between almost any language is that they are usually dead simple to make bindings to C code. I also wanted Chipmunk2D to be fast, portable, easy to optimize and easy to debug. Writing Chipmunk2D in C made it simpler to achieve all of those goals.</p>
<p>That said, I've never developed a whole game in C and I probably never will. There are much more interesting and fun languages than C with all sorts of nice features like garbage collection, closures and all sorts of unique object-oriented runtimes. Check out the <a href="http://chipmunk2d.net/bindingsAndPorts.php">Bindings and Ports</a> page to see if you can use Chipmunk2D from your language of choice. Because Chipmunk2D is written in a subset of C99 it compiles cleanly as C, C++, Objective-C and Objective-C++ code, making it easy to integrate into projects in those languages.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Limitations of a C API</h2>
<p>Chipmunk does provide overloaded operators for <code>*</code>, <code>+</code>, and <code>-</code> (unary and binary) if you are using C++, but falls back to using functions such as <code><a class="el" href="group__cp_vect.html#ga167e0bde13a745299bd5d4164d7c796b" title="Add two vectors.">cpvadd()</a></code> and <code><a class="el" href="group__cp_vect.html#gafd88a5bbd4b5de25aa31e44fdf01e259" title="Subtract two vectors.">cpvsub()</a></code> for C code. This is a little harder to read, but works OK once you get used to it. Most of the interesting vector operations that are possible don't have a symbol for them anyway (at least not on a keyboard).</p>
<p>Another problem for a C API is access restriction. There are many structs, fields and functions in Chipmunk that are only meant to be used internally. To work around this, I have a separate header full of Chipmunk's private API, <code><a class="el" href="chipmunk__private_8h_source.html">chipmunk_private.h</a></code>. I also use a macro, <code>CP_PRIVATE()</code> to mangle names in public structures. While you can feel free to include this header or use the macro in your own code to access the private API, be aware that the fields and functions may be renamed or disappear without warning and I have no plans to document or support usage of the private API.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Get it, Compile it</h1>
<p>If you haven't downloaded it yet, you can always download the newest version of Chipmunk2D <a href="http://chipmunk-physics.net/release/ChipmunkLatest.tgz">here</a>. Inside you'll find a command line build script that works with <a href="http://www.cmake.org/">CMake</a>, a XCode project and project files for Visual Studio '09 and '10.</p>
<h3><a class="anchor" id="autotoc_md4"></a>
Debug or Release?</h3>
<p>Debug mode might be slightly slower, but will include a lot of error checking assertions that can help you find bugs quicker such as removing objects twice or doing things that might cause unsolvable collisions. I highly recommend you use a debug build until you are ready to ship the game and only then switch to a release build.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
XCode (Mac/iPhone)</h3>
<p>The included XCode project has targets for building a static library for the Mac or iOS. Additionally, you might want to just run the <code>xcode/iphonestatic.command</code> or <code>xcode/macstatic.command</code> to build you a directory with the headers and debug/release static libraries that you can just drop right into your projects. Including Chipmunk in your project with all the correct compiler flags applied couldn't be simpler. The iPhone script generates a "fat" library that can be used with both the iOS simulator and devices. The device version is compiled as release, and the simulator version is compiled as debug.</p>
<h3><a class="anchor" id="autotoc_md6"></a>
MSVC</h3>
<p>I rarely use MSVC, but others have chipped in to help me maintain Visual Studio project files. The MSVC 10 project should work, as I usually remember to test that before making a stable release. The MSVC 9 project may not as I don't have access to that version. Let me know if there are any issues.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
Command Line</h3>
<p>The CMake build script should work on any system (Unix/Win/Mac) as long as you have CMake installed. It can even generate XCode or MSVC projects if you want (see CMake's documentation for more information).</p>
<p>To compile a Chipmunk debug build on the command line, all you need to do is run: </p><pre class="fragment">&lt;code&gt;cmake -D CMAKE_BUILD_TYPE=Debug .
make&lt;/code&gt;
</pre><p> If the <code>-D CMAKE_BUILD_TYPE=Debug</code> option is left out, it will make a release build instead.</p>
<p>Why CMake? Somebody was kind enough to create the build scripts for me originally, and it seems to handle a lot of the cross-platform issues nicely. I know some people really hate having to install some random non-make build system in order to compile things, but it has saved me a lot of time and effort.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Hello Chipmunk (World)</h2>
<p>Hello world Chipmunk style. Create a simple simulation where a ball falls onto a static line segment, then rolls off. Print out the coordinates of the ball.</p>
<p>&lt;%= pop_open_example "Hello Chipmunk" %&gt;</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Support</h2>
<p>The best way to get support is to visit the <a href="http://www.slembcke.net/forums/viewforum.php?f=1">Chipmunk Forums</a>. There are plenty of people around using Chipmunk on the just about every platform I've ever heard of. If you are working on a commercial project, Howling Moon Software (my company) is <a href="http://howlingmoonsoftware.com/contracting.php">available for contracting</a>. We can help with implementing custom Chipmunk behaviors, as well as priority bug fixes and performance tuning.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Contact</h2>
<p>If you find any bugs in Chipmunk, errors or broken links in this document, or have a question or comment about Chipmunk you can contact me at slembcke(at)gmail(dot)com. (email or GTalk)</p>
<h2><a class="anchor" id="autotoc_md11"></a>
License</h2>
<p>Chipmunk is licensed under the MIT license. </p><pre class="fragment">Copyright (c) 2007-2015 Scott Lembcke and Howling Moon Software

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</pre><p> This means that you do not have to buy a license or pay to use Chipmunk in commercial projects. (Though we really appreciate donations)</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Links</h2>
<ul>
<li><a href="http://chipmunk2d.net/forum">Chipmunk Forums</a> - The official forum Chipmunk2D forum.</li>
<li><a href="http://howlingmoonsoftware.com/">Howling Moon Software</a> - The software company I co-founded. (We are available for contract work!)</li>
<li><a href="http://chipmunk2d.net/games.php">Games</a> - A small list of games we know that use Chipmunk.</li>
</ul>
<h1><a class="anchor" id="autotoc_md13"></a>
Chipmunk2D Basics</h1>
<h2><a class="anchor" id="autotoc_md14"></a>
Overview</h2>
<p>There are 4 basic object types you will use in Chipmunk.</p>
<ul>
<li><b>Rigid Bodies:</b> A rigid body holds the physical properties of an object. (mass, position, rotation, velocity, etc.) It does not have a shape until you attach one or more collision shapes to it. If you've done physics with particles before, rigid bodies differ in that they are able to rotate. Rigid bodies generally tend to have a 1:1 correlation to sprites in a game. You should structure your game so that you use the position and rotation of the rigid body for drawing your sprite.</li>
<li><b>Collision Shapes:</b> By attaching shapes to bodies, you can define the a body's shape. You can attach as many shapes to a single body as you need to in order to define a complex shape. Shapes contain the surface properties of an object such as how much friction or elasticity it has.</li>
<li><b>Constraints/Joints:</b> Constraints and joints describe how bodies are attached to each other.</li>
<li><b>Spaces:</b> Spaces are containers for simulating objects in Chipmunk. You add bodies, shapes and joints to a space and then update the space as a whole. They control how all the rigid bodies, shapes, and constraints interact together.</li>
</ul>
<p>There is often confusion between rigid bodies and their collision shapes in Chipmunk and how they relate to sprites. A sprite would be a visual representation of an object, while a collision shape is an invisible property that defines how objects should collide. Both the sprite's and the collision shape's position and rotation are controlled by the motion of a rigid body. Generally you want to create a game object type that ties these things all together.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Memory Management the Chipmunk way</h2>
<p>For most of the structures you will use, Chipmunk uses a more or less standard and straightforward set of memory management functions. Take the <a class="el" href="group__cp_space.html">cpSpace</a> struct for example:</p>
<ul>
<li><code><a class="el" href="group__cp_space.html#ga2d7724bac5766902583bfc4a4f06ca32" title="Allocate and initialize a cpSpace.">cpSpaceNew()</a></code> - Allocates and initializes a <code><a class="el" href="structcp_space.html">cpSpace</a></code> struct. It calls <code><a class="el" href="group__cp_space.html#gaa233bc692b8773035e0b7af246f1785f" title="Allocate a cpSpace.">cpSpaceAlloc()</a></code> then <code><a class="el" href="group__cp_space.html#ga4f6c77afe3cef0d06df38b7aa8d70354" title="Initialize a cpSpace.">cpSpaceInit()</a></code>.</li>
<li><code><a class="el" href="group__cp_space.html#gab1bc162df996c03493be80d8220e5c8a" title="Destroy and free a cpSpace.">cpSpaceFree(cpSpace *space)</a></code> - Destroys and frees the <code><a class="el" href="structcp_space.html">cpSpace</a></code> struct.</li>
</ul>
<p>You are responsible for freeing any structs that you allocate. Chipmunk does not do reference counting or garbage collection. If you call a <code>new</code> function, you must call the matching <code>free</code> function or you will leak memory.</p>
<p>Additionally if you need more control over allocation and initialization because you are allocating temporary structs on the stack, writting a language binding, or working in a low memory environment you can also use the following functions. <em>Most people will never have any need to use these functions.</em></p>
<ul>
<li><code><a class="el" href="group__cp_space.html#gaa233bc692b8773035e0b7af246f1785f" title="Allocate a cpSpace.">cpSpaceAlloc()</a></code> - Allocates but does not initialize a <code><a class="el" href="structcp_space.html">cpSpace</a></code> struct. All allocation functions look more or less like this: <code>return (<a class="el" href="structcp_space.html">cpSpace</a> *)<a class="el" href="group__misc.html#gac88bab87ecc7db6cc222679bf6082e9b" title="Chipmunk calloc() alias.">cpcalloc(1, sizeof(cpSpace))</a>;</code> You can write your own allocation functions if you want. It is not a requirement that the memory be zeroed.</li>
<li><code><a class="el" href="group__cp_space.html#ga4f6c77afe3cef0d06df38b7aa8d70354" title="Initialize a cpSpace.">cpSpaceInit(cpSpace *space)</a></code> - Initializes a <code><a class="el" href="structcp_space.html">cpSpace</a></code> struct.</li>
<li><code><a class="el" href="group__cp_space.html#gaaf1097ee4fb04f32c4e82271d7603d26" title="Destroy a cpSpace.">cpSpaceDestroy(cpSpace *space)</a></code> - Frees all memory allocated by <code><a class="el" href="group__cp_space.html#ga4f6c77afe3cef0d06df38b7aa8d70354" title="Initialize a cpSpace.">cpSpaceInit()</a></code>, but does not free the <code><a class="el" href="structcp_space.html">cpSpace</a></code> struct itself.</li>
</ul>
<p>Like calls to the <code>new</code> and <code>free</code> functions. Any memory allocated by an <code>alloc</code> function must be freed by <code><a class="el" href="group__misc.html#ga14627263deb67605201281bac734eb04" title="Chipmunk free() alias.">cpfree()</a></code> or similar. Any call to an <code>init</code> function must be matched with its <code>destroy</code> function.</p>
<p>To further ease integration with garbage collectors or other memory management constraints, Chipmunk has a number of compile time defines (<code><a class="el" href="group__misc.html#gac88bab87ecc7db6cc222679bf6082e9b" title="Chipmunk calloc() alias.">cpcalloc()</a></code>, <code><a class="el" href="group__misc.html#gab3544b888840ed34e49bb0559d6849a8" title="Chipmunk realloc() alias.">cprealloc()</a></code>, and <code><a class="el" href="group__misc.html#ga14627263deb67605201281bac734eb04" title="Chipmunk free() alias.">cpfree()</a></code>) that can be overriden. If you aren't using Chipmunk from a garbage collected language, I'd highly recommend using libGC. It provides nearly transparent garbage collection for C based languages.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Basic Types</h2>
<p><code><a class="el" href="chipmunk__types_8h_source.html">chipmunk_types.h</a></code> defines a number of basic types that Chipmunk uses. These can be changed at compile time to better suit your needs:</p>
<ul>
<li><code>cpFloat</code>: Floating point type. Defaults to <code>double</code>.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a></code>: 2D vector type. <a class="el" href="group__cp_vect.html">cpVect documentation</a></li>
<li><code>cpBool</code>: Like every good C library that wants good cross language compatibility, you end up defining your own boolean type. :-\ Defaults to <code>int</code>.</li>
<li><code>cpDataPointer</code>: Pointer type defined for callbacks and the user definable data pointer on most Chipmunk structs. Defaults to <code>void*</code>.</li>
<li><code>cpCollisionType</code>: Unique identifier for collision shape types. Defaults to <code>unsigned int</code>. Defined type must support the <code>==</code> operator.</li>
<li><code>cpGroup</code>: Unique identifier for collision groups. Defaults to <code>unsigned int</code>. A <code>CP_NO_GROUP</code> value is defined that can be used when you don't want to specify a group. Defined type must support the equality <code>==</code> operator.</li>
<li><code>cpBitmask</code>: Type used for collision filter categories and masks. Defaults to <code>unsigned int</code>. Defined type must support the bitwise AND <code>&amp;</code> operator.</li>
<li><code><a class="el" href="structcp_transform.html" title="Column major affine transform.">cpTransform</a></code>: Type used for 2x3 affine transforms in Chipmunk.</li>
</ul>
<p>If you are writting a game engine or language binding on top of Chipmunk, you might want to choose to use object references instead of integers for collision type and group. I often use class pointers for collision types and game object pointers for groups. It's much simpler than keeping a table of enumerations around.</p>
<p><b>Note:</b> On the iPhone, <code>cpFloat</code> is defined as <code>float</code> and <code><a class="el" href="structcp_vect.html">cpVect</a></code> is an alias for <code>CGPoint</code> for performance and compatibility reasons.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Math the Chipmunk way</h2>
<p>First of all, Chipmunk uses double precision floating point numbers throughout its calculations by default. This is likely to be faster on most modern desktop processors, and means you don't have to worry as much about floating point accuracy. You can change the floating point type used by Chipmunk when compiling the library. Look in <code><a class="el" href="chipmunk__types_8h_source.html">chipmunk_types.h</a></code>.</p>
<p>Chipmunk defines a number of aliases for common math functions so that you can choose to use floats or doubles for Chipmunk's floating point type. In your own code, there probably isn't a strong reason to use these aliases unless you expect you might want to change Chipmunk's floating point type later and a 2% performance hit from using the wrong float/double version of math functions will matter.</p>
<p>However, there are a few unique functions you will probably find very useful:</p>
<ul>
<li><code>cpFloat <a class="el" href="group__basic_types.html#ga2498b1f14da6398233b93e457d37327e" title="Clamp f to be between min and max.">cpfclamp(cpFloat f, cpFloat min, cpFloat max)</a></code> - Clamp <code>f</code> to be between <code>min</code> and <code>max</code>.</li>
<li><code>cpFloat <a class="el" href="group__basic_types.html#gac4b6dc30e9ed3e2c9c8661102489c0c0" title="Linearly interpolate (or extrapolate) between f1 and f2 by t percent.">cpflerp(cpFloat f1, cpFloat f2, cpFloat t)</a></code> - Linearly interpolate between <code>f1</code> and <code>f2</code>.</li>
<li><code>cpFloat <a class="el" href="group__basic_types.html#ga191b1d47e2b846cad0ee54572b366f0d" title="Linearly interpolate from f1 to f2 by no more than d.">cpflerpconst(cpFloat f1, cpFloat f2, cpFloat d)</a></code> - Linearly interpolate from <code>f1</code> towards <code>f2</code> by no more than <code>d</code>.</li>
</ul>
<p>Floating point infinity is defined as <code>INFINITY</code>. This is defined by many math libraries, but is not actually part of the C standard library.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Chipmunk Vectors: &lt;tt&gt;cpVect&lt;/tt&gt;</h1>
<h2><a class="anchor" id="autotoc_md19"></a>
Struct Definition, Constants and Constructors</h2>
<pre class="fragment">&lt;code&gt;typedef struct cpVect{
    cpFloat x, y;
} cpVect&lt;/code&gt;
</pre><p> ::: expl 2D vector packed into a struct. No surprises here. ::: </p><pre class="fragment">&lt;code&gt;static const cpVect cpvzero = {0.0f,0.0f};&lt;/code&gt;
</pre><p> ::: expl Constant for the zero vector. ::: </p><pre class="fragment">&lt;code&gt;cpVect cpv(const cpFloat x, const cpFloat y)&lt;/code&gt;
</pre><p> ::: expl Convenience constructor for creating new <code><a class="el" href="structcp_vect.html">cpVect</a></code> structs. :::</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Operations</h2>
<ul>
<li><code>cpBool <a class="el" href="group__cp_vect.html#gae5081f933bcc2c64c76d7e7caaf2d631" title="Check if two vectors are equal. (Be careful when comparing floating point numbers!...">cpveql(const cpVect v1, const cpVect v2)</a></code> - Check if two vectors are equal. Chipmunk provides an overloaded <code>==</code> operator when used in C++ programs. <em>[]{.numbers! .point .floating .comparing .when .careful .Be}</em></li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_vect.html#ga167e0bde13a745299bd5d4164d7c796b" title="Add two vectors.">cpvadd(const cpVect v1, const cpVect v2)</a></code> - Add two vectors. Chipmunk provides an overloaded <code>+</code> operator when used in C++ programs.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_vect.html#gafd88a5bbd4b5de25aa31e44fdf01e259" title="Subtract two vectors.">cpvsub(const cpVect v1, const cpVect v2)</a></code> - Subtract two vectors. Chipmunk provides an overloaded <code>-</code> operator when used in C++ programs.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_vect.html#gab79a1d52de40bf0f7db5134da436426b" title="Negate a vector.">cpvneg(const cpVect v)</a></code> - Negate a vector. Chipmunk provides an overloaded unary negation operator <code>-</code> when used in C++ programs.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_vect.html#ga717188d925550baf62188b5e1e602047" title="Scalar multiplication.">cpvmult(const cpVect v, const cpFloat s)</a></code> - Scalar multiplication. Chipmunk provides an overloaded <code>*</code> operator when used in C++ programs.</li>
<li><code>cpFloat <a class="el" href="group__cp_vect.html#ga3e76653b018d47f864c339092cf482f1" title="Vector dot product.">cpvdot(const cpVect v1, const cpVect v2)</a></code> - Vector dot product.</li>
<li><code>cpFloat <a class="el" href="group__cp_vect.html#gaf9618b7690ad0c67dbe143c640590f7b" title="2D vector cross product analog.">cpvcross(const cpVect v1, const cpVect v2)</a></code> - 2D vector cross product analog. The cross product of 2D vectors results in a 3D vector with only a z component. This function returns the value along the z-axis.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_vect.html#gac4a0ba2873900342126c0449918764bc" title="Returns a perpendicular vector. (90 degree rotation)">cpvperp(const cpVect v)</a></code> - Returns a perpendicular vector. (90 degree rotation)</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_vect.html#ga0be2829df5c1be940484fb64b7cab61e" title="Returns a perpendicular vector. (-90 degree rotation)">cpvrperp(const cpVect v)</a></code> - Returns a perpendicular vector. (&ndash;90 degree rotation)</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_vect.html#gae9c42ec78caa7971459d10543b1549cd" title="Returns the vector projection of v1 onto v2.">cpvproject(const cpVect v1, const cpVect v2)</a></code> - Returns the vector projection of <code>v1</code> onto <code>v2</code>.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_vect.html#gac9a0bb9221f9f2068a48985fa70b5226" title="Uses complex number multiplication to rotate v1 by v2. Scaling will occur if v1 is not a unit vector.">cpvrotate(const cpVect v1, const cpVect v2)</a></code> - Uses complex multiplication to rotate <code>v1</code> by <code>v2</code>. Scaling will occur if <code>v1</code> is not a unit vector.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_vect.html#gac2b1120be08ee9225eadede83f5e054b" title="Inverse of cpvrotate().">cpvunrotate(const cpVect v1, const cpVect v2)</a></code> - Inverse of <code><a class="el" href="group__cp_vect.html#gac9a0bb9221f9f2068a48985fa70b5226" title="Uses complex number multiplication to rotate v1 by v2. Scaling will occur if v1 is not a unit vector.">cpvrotate()</a></code>.</li>
<li><code>cpFloat <a class="el" href="group__cp_vect.html#ga9bfe76d8e3c69edb6af7b0d9a63001f9" title="Returns the length of v.">cpvlength(const cpVect v)</a></code> - Returns the length of <code>v</code>.</li>
<li><code>cpFloat <a class="el" href="group__cp_vect.html#gadfad8e091ac399cdc377a9c475f7ef0d" title="Returns the squared length of v. Faster than cpvlength() when you only need to compare lengths.">cpvlengthsq(const cpVect v)</a></code> - Returns the squared length of <code>v</code>. Faster than <code><a class="el" href="group__cp_vect.html#ga9bfe76d8e3c69edb6af7b0d9a63001f9" title="Returns the length of v.">cpvlength()</a></code> when you only need to compare lengths.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_vect.html#gab93f4924f5369c10782de6dba5ef38da" title="Linearly interpolate between v1 and v2.">cpvlerp(const cpVect v1, const cpVect v2, const cpFloat t)</a></code> - Linearly interpolate between <code>v1</code> and <code>v2</code>.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_vect.html#gaaf91d2bdafb741a35ab2dc6300d9fa81" title="Linearly interpolate between v1 towards v2 by distance d.">cpvlerpconst(cpVect v1, cpVect v2, cpFloat d)</a></code> - Linearly interpolate between <code>v1</code> towards <code>v2</code> by distance <code>d</code>.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_vect.html#ga6c7b8f231543383431aeb80e61255e04" title="Spherical linearly interpolate between v1 and v2.">cpvslerp(const cpVect v1, const cpVect v2, const cpFloat t)</a></code> - Spherical linearly interpolate between <code>v1</code> and <code>v2</code>.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_vect.html#gad81f538a3add6e5e1498645ebecb8ed1" title="Spherical linearly interpolate between v1 towards v2 by no more than angle a radians.">cpvslerpconst(const cpVect v1, const cpVect v2, const cpFloat a)</a></code> - Spherical linearly interpolate between <code>v1</code> towards <code>v2</code> by no more than angle <code>a</code> in radians.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_vect.html#ga0fd46c6ef6dcca0dc7b6c6cef8008758" title="Returns a normalized copy of v.">cpvnormalize(const cpVect v)</a></code> - Returns a normalized copy of <code>v</code>. As a special case, it returns <code>cpvzero</code> when called on <code>cpvzero</code>.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_vect.html#ga21bac66ee11661debe4d1ddfb710f5f8" title="Clamp v to length len.">cpvclamp(const cpVect v, const cpFloat len)</a></code> - Clamp <code>v</code> to length <code>len</code>.</li>
<li><code>cpFloat <a class="el" href="group__cp_vect.html#ga07488fb10c3ffb842b78ae66a2d90c00" title="Returns the distance between v1 and v2.">cpvdist(const cpVect v1, const cpVect v2)</a></code> - Returns the distance between <code>v1</code> and <code>v2</code>.</li>
<li><code>cpFloat <a class="el" href="group__cp_vect.html#gadb0ce5353909318beb7ee3163f7c3152" title="Returns the squared distance between v1 and v2. Faster than cpvdist() when you only need to compare d...">cpvdistsq(const cpVect v1, const cpVect v2)</a></code> - Returns the squared distance between <code>v1</code> and <code>v2</code>. Faster than <code><a class="el" href="group__cp_vect.html#ga07488fb10c3ffb842b78ae66a2d90c00" title="Returns the distance between v1 and v2.">cpvdist()</a></code> when you only need to compare distances.</li>
<li><code>cpBool <a class="el" href="group__cp_vect.html#ga2ffc18e3b7405c28e92b6aa0f6cad746" title="Returns true if the distance between v1 and v2 is less than dist.">cpvnear(const cpVect v1, const cpVect v2, const cpFloat dist)</a></code> - Returns true if the distance between <code>v1</code> and <code>v2</code> is less than <code>dist</code>.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_vect.html#gafa534ef07bb623104c576f63cbc6334a" title="Returns the unit length vector for the given angle (in radians).">cpvforangle(const cpFloat a)</a></code> - Returns the unit length vector for the given angle (in radians).</li>
<li><code>cpFloat <a class="el" href="group__cp_vect.html#ga8ee2e1733c8ed09f2230a5788bd284e9" title="Returns the angular direction v is pointing in (in radians).">cpvtoangle(const cpVect v)</a></code> - Returns the angular direction <code>v</code> is pointing in (in radians).</li>
</ul>
<h1><a class="anchor" id="autotoc_md21"></a>
Chipmunk Axis Aligned Bounding Boxes: &lt;tt&gt;cpBB&lt;/tt&gt;</h1>
<h2><a class="anchor" id="autotoc_md22"></a>
Struct Definition and Constructors</h2>
<pre class="fragment">&lt;code&gt;typedef struct cpBB{
    cpFloat l, b, r ,t;
} cpBB&lt;/code&gt;
</pre><p> ::: expl Simple bounding box struct. Stored as left, bottom, right, top values. ::: </p><pre class="fragment">&lt;code&gt;cpBB cpBBNew(const cpFloat l, const cpFloat b, const cpFloat r, const cpFloat t)&lt;/code&gt;
</pre><p> ::: expl Convenience constructor for <code><a class="el" href="structcp_b_b.html" title="Chipmunk&#39;s axis-aligned 2D bounding box type. (left, bottom, right, top)">cpBB</a></code> structs. Like <code><a class="el" href="group__cp_vect.html#ga80c0be464748ff46ad20b58e22ea7d81" title="Convenience constructor for cpVect structs.">cpv()</a></code> this function returns a copy and not a malloced pointer. ::: </p><pre class="fragment">&lt;code&gt;cpBB cpBBNewForExtents(const cpVect c, const cpFloat hw, const cpFloat hh)&lt;/code&gt;
</pre><p> ::: expl Convenience constructor for making a <code><a class="el" href="structcp_b_b.html" title="Chipmunk&#39;s axis-aligned 2D bounding box type. (left, bottom, right, top)">cpBB</a></code> fitting with a center point and half width and height. ::: </p><pre class="fragment">&lt;code&gt;cpBB cpBBNewForCircle(const cpVect p, const cpFloat r)&lt;/code&gt;
</pre><p> ::: expl Convenience constructor for making a <code><a class="el" href="structcp_b_b.html" title="Chipmunk&#39;s axis-aligned 2D bounding box type. (left, bottom, right, top)">cpBB</a></code> fitting a circle at position <code>p</code> with radius <code>r</code>. :::</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Operations</h2>
<ul>
<li><code>cpBool <a class="el" href="group__cp_b_b_b.html#gac4a5fd7846b67f8711d3afb7536adbd5" title="Returns true if a and b intersect.">cpBBIntersects(const cpBB a, const cpBB b)</a></code> - Returns true if the bounding boxes intersect.</li>
<li><code>cpBool <a class="el" href="group__cp_b_b_b.html#gae0f2d67ca77b4b510c1a9c3a744627ba" title="Returns true if other lies completely within bb.">cpBBContainsBB(const cpBB bb, const cpBB other)</a></code> - Returns true if <code>bb</code> completely contains <code>other</code>.</li>
<li><code>cpBool <a class="el" href="group__cp_b_b_b.html#gaee3aab91cca0adbe8c830cac0951da6a" title="Returns true if bb contains v.">cpBBContainsVect(const cpBB bb, const cpVect v)</a></code> - Returns true if <code>bb</code> contains <code>v</code>.</li>
<li><code><a class="el" href="structcp_b_b.html" title="Chipmunk&#39;s axis-aligned 2D bounding box type. (left, bottom, right, top)">cpBB</a> <a class="el" href="group__cp_b_b_b.html#gacde4506e27649bb6773009c337266d0d" title="Returns a bounding box that holds both bounding boxes.">cpBBMerge(const cpBB a, const cpBB b)</a></code> - Return the minimal bounding box that contains both <code>a</code> and <code>b</code>.</li>
<li><code><a class="el" href="structcp_b_b.html" title="Chipmunk&#39;s axis-aligned 2D bounding box type. (left, bottom, right, top)">cpBB</a> <a class="el" href="group__cp_b_b_b.html#gad995b2feaa55d6bc858e8f930a4ed325" title="Returns a bounding box that holds both bb and v.">cpBBExpand(const cpBB bb, const cpVect v)</a></code> - Return the minimal bounding box that contains both <code>bb</code> and <code>v</code>.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_b_b_b.html#ga341e84758fe8fd212e6af09385ecece6" title="Returns the center of a bounding box.">cpBBCenter(const cpBB bb)</a></code> - Return the center of <code>bb</code>.</li>
<li><code>cpFloat <a class="el" href="group__cp_b_b_b.html#gadc31eb18f01b1200938b21ed7e35257a" title="Returns the area of the bounding box.">cpBBArea(cpBB bb)</a></code> - Return the area of <code>bb</code>.</li>
<li><code>cpFloat <a class="el" href="group__cp_b_b_b.html#ga89f37acb475dd1dc1b6571282033c0f0" title="Merges a and b and returns the area of the merged bounding box.">cpBBMergedArea(cpBB a, cpBB b)</a></code> - Merges <code>a</code> and <code>b</code> then returns the area of the merged bounding box.</li>
<li><code>cpFloat <a class="el" href="group__cp_b_b_b.html#gaf623a5ee2e14df8c002fd742b08686d1" title="Returns the fraction along the segment query the cpBB is hit. Returns INFINITY if it doesn&#39;t hit.">cpBBSegmentQuery(cpBB bb, cpVect a, cpVect b)</a></code> - Returns the fraction along the segment query the <a class="el" href="structcp_b_b.html" title="Chipmunk&#39;s axis-aligned 2D bounding box type. (left, bottom, right, top)">cpBB</a> is hit. Returns INFINITY if it doesn't hit.</li>
<li><code>cpBool <a class="el" href="group__cp_b_b_b.html#ga65157a1d957e6069aef614dca588a705" title="Return true if the bounding box intersects the line segment with ends a and b.">cpBBIntersectsSegment(cpBB bb, cpVect a, cpVect b)</a></code> - Returns true if the segment defined by endpoints <code>a</code> and <code>b</code> intersect <code>bb</code>.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_b_b_b.html#gac27ebb67e71268f471c2a4ad2658f23f" title="Clamp a vector to a bounding box.">cpBBClampVect(const cpBB bb, const cpVect v)</a></code> - Returns a copy of <code>v</code> clamped to the bounding box.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_b_b_b.html#ga0fbeae861bcd6e1ea09adeca277c5686" title="Wrap a vector to a bounding box.">cpBBWrapVect(const cpBB bb, const cpVect v)</a></code> - Returns a copy of <code>v</code> wrapped to the bounding box.</li>
</ul>
<h1><a class="anchor" id="autotoc_md24"></a>
Chipmunk Rigid Bodies: &lt;tt&gt;cpBody&lt;/tt&gt;</h1>
<h2><a class="anchor" id="autotoc_md25"></a>
Dynamic, Kinematic, and Static Bodies</h2>
<p>Chipmunk supports three different types of bodies with unique behavioral and performance characteristics.</p>
<p>Dynamic bodies are the default body type. They react to collisions, are affected by forces and gravity, and have a finite amount of mass. These are the type of bodies that you want the physics engine to simulate for you. Dynamic bodies interact with all types of bodies and can generate collision callbacks.</p>
<p>Kinematic bodies are bodies that are controlled from your code instead of inside the physics engine. They arent affected by gravity and they have an infinite amount of mass so they don't react to collisions or forces with other bodies. Kinematic bodies are controlled by setting their velocity, which will cause them to move. Good examples of kinematic bodies might include things like moving platforms. Objects that are touching or jointed to a kinematic body are never allowed to fall asleep.</p>
<p>Static bodies are bodies that never (or rarely) move. Using static bodies for things like terrain offers a big performance boost over other body types- because Chipmunk doesn't need to check for collisions between static objects and it never needs to update their collision information. Additionally, because static bodies don't move, Chipmunk knows it's safe to let objects that are touching or jointed to them fall asleep. Generally all of your level geometry will be attached to a static body except for things like moving platforms or doors. Every space provide a built-in static body for your convenience. Static bodies can be moved, but there is a performance penalty as the collision information is recalculated. There is no penalty for having multiple static bodies, and it can be useful for simplifying your code by allowing different parts of your static geometry to be initialized or moved separately.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Movement, Teleportation, and Velocity</h2>
<p>A graphics engine only needs to know the position of an object for each frame that its drawn. For a physics engine, this isn't enough information to calculate a collision response. When you set the position of a body, you are effectively asking it to teleport itself. This means that it will instantly move to its new position instead of moving through space and time like a normal object. If you teleport an object so that it overlaps another one, the best the physics engine can do is to attempt to push the objects apart again since there is no information about their movement. This generally results in very mushy looking collisions. So instead of setting the position of an object, it's better to set its velocity and allow the physics engine to update the position. That way it can resolve any resulting colisions natuarally since it knows how the objects were moving. This is why kinematic bodies work the way they do. You set the velocity, and the physics updates their position so the two are never out of sync.</p>
<p>For dynamic bodies, setting the velocity explicitly every frame can cause problems. For example, a problem occurs when a light dynamic body (like a person) is pressed against a heavy dynamic body (like a car), and you set velocity of the small object so that it's pushing it into the big body. To the physics engine, the change in velocity is the same as applying a large impulse (a very short, very large force). Even if the velocity is low, the large force can allow the small body to push the big body, even when it normally wouldn't be able to. For example, a person walking into a car can overpower the car's friction and cause it to creep along the ground slowly. Additionally, when you set the velocity of an object that is already in contact, it can cause the two objects to overlap by a small amount. The easiest way to avoid both of these problems is to make smaller changes to the body's velocity, accelerating it over a fraction of a second instead of a single frame. An even better solution is to use constraints to move the object. For an example, look at how the Tank and Crane demos drive their constraints and use the maximum bias and force properties. The mouse control in the demo application works the same way.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Memory Management Functions</h2>
<pre class="fragment">&lt;code&gt;cpBody *cpBodyAlloc(void)
cpBody *cpBodyInit(cpBody *body, cpFloat m, cpFloat i)
cpBody *cpBodyNew(cpFloat m, cpFloat i)

cpBody *cpBodyInitKinematic(cpBody *body)
cpBody *cpBodyNewKinematic()

cpBody *cpBodyInitStatic(cpBody *body)
cpBody *cpBodyNewStatic()

void cpBodyDestroy(cpBody *body)
void cpBodyFree(cpBody *body)&lt;/code&gt;
</pre><p> ::: expl Standard set of Chipmunk memory management functions. <code>m</code> and <code>i</code> are the mass and moment of inertia for the body. Guessing the mass for a body is usually fine, but guessing a moment of inertia can lead to a very poor simulation so it's recommended to use Chipmunk's moment calculations to estimate the moment for you. Be careful not to free a body before any shapes or constraints attached to it have been removed from a space. :::</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Creating Dynamic Bodies</h2>
<p>There are two ways to set up a dynamic body. The easiest option is to create a body with a mass and moment of 0, and set the mass or density of each collision shape added to the body. Chipmunk will automatically calculate the mass, moment of inertia, and center of gravity for you. This is probably preferred in most cases.</p>
<p>TODO example</p>
<p>The other option is to set the mass of the body when it's created, and leave the mass of the shapes added to it as 0.0. This approach is more flexible, but is not as easy to use. <b>Don't</b> set the mass of both the body and the shapes. If you do so, it will recalculate and overwrite your custom mass value when the shapes are added to the body.</p>
<p>TODO example</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Properties</h2>
<p>Chipmunk provides getter/setter functions for a number of properties on rigid bodies. Setting most properties automatically wakes the rigid bodies up if they were sleeping. You can also set the fields directly on the <a class="el" href="structcp_body.html">cpBody</a> struct if you wish. They are documented in the headers. </p><pre class="fragment">&lt;code&gt;cpBodyType cpBodyGetType(const cpBody *body)
void cpBodySetType(cpBody *body, cpBodyType)&lt;/code&gt;
</pre><p> ::: expl Set the type of a body (dynamic, kinematic, static). See the section on BodyTypes for more information. When changing an body to a dynamic body, the mass and moment of inertia are recalculated from the shapes added to the body. Custom calculated moments of inertia are not preserved when changing types. This function cannot be called directly in a collision callback. See Post-Step Callbacks for more information. ::: </p><pre class="fragment">&lt;code&gt;cpSpace *cpBodyGetSpace(const cpBody *body)&lt;/code&gt;
</pre><p> ::: expl The <code><a class="el" href="structcp_space.html">cpSpace</a></code> this body is currently added to, or <code>NULL</code> if it is not currently added to a space. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpBodyGetMass(const cpBody *body)
void cpBodySetMass(cpBody *body, cpFloat m)&lt;/code&gt;
</pre><p> ::: expl Mass of the body. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpBodyGetMoment(const cpBody *body)
void cpBodySetMoment(cpBody *body, cpFloat i)&lt;/code&gt;
</pre><p> ::: expl Moment of inertia (MoI or sometimes just moment) of the body. The moment is like the rotational mass of a body. See below for function to help calculate the moment. ::: </p><pre class="fragment">&lt;code&gt;cpVect cpBodyGetPosition(const cpBody *body)
void cpBodySetPosition(cpBody *body, cpVect pos)&lt;/code&gt;
</pre><p> ::: expl Position of the body. When changing the position you may also want to call <code><a class="el" href="group__cp_space.html#ga9a141b9c927102b02a84bb2b8631f803" title="Update the collision detection data for all shapes attached to a body.">cpSpaceReindexShapesForBody()</a></code> to update the collision detection information for the attached shapes if plan to make any queries against the space. ::: </p><pre class="fragment">&lt;code&gt;cpVect cpBodyGetCenterOfGravity(const cpBody *body)
void cpBodySetCenterOfGravity(cpBody *body, cpVect cog)&lt;/code&gt;
</pre><p> ::: expl Location of the center of gravity in body local coordinates. The default value is <code>(0, 0)</code>, meaning the center of gravity is the same as the position of the body. ::: </p><pre class="fragment">&lt;code&gt;cpVect cpBodyGetVelocity(const cpBody *body)
void cpBodySetVelocity(cpBody *body, const cpVect value)&lt;/code&gt;
</pre><p> ::: expl Linear velocity of the center of gravity of the body. ::: </p><pre class="fragment">&lt;code&gt;cpVect cpBodyGetForce(const cpBody *body)
void cpBodySetForce(cpBody *body, const cpVect value)&lt;/code&gt;
</pre><p> ::: expl Force applied to the center of gravity of the body. This value is reset for every time step. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpBodyGetAngle(const cpBody *body)
void cpBodySetAngle(cpBody *body, cpFloat a)&lt;/code&gt;
</pre><p> ::: expl Rotation of the body in radians. When changing the rotation you may also want to call <code><a class="el" href="group__cp_space.html#ga9a141b9c927102b02a84bb2b8631f803" title="Update the collision detection data for all shapes attached to a body.">cpSpaceReindexShapesForBody()</a></code> to update the collision detection information for the attached shapes if plan to make any queries against the space. A body rotates around its center of gravity, not its position. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpBodyGetAngularVelocity(const cpBody *body)
void cpBodySetAngularVelocity(cpBody *body, const cpFloat value)&lt;/code&gt;
</pre><p> ::: expl The angular velocity of the body in radians per second. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpBodyGetTorque(const cpBody *body)
void cpBodySetTorque(cpBody *body, const cpFloat value)&lt;/code&gt;
</pre><p> ::: expl The torque applied to the body. This value is reset for every time step. ::: </p><pre class="fragment">&lt;code&gt;cpVect cpBodyGetRotation(const cpBody *body)&lt;/code&gt;
</pre><p> ::: expl The rotation vector for the body. Can be used with <code><a class="el" href="group__cp_vect.html#gac9a0bb9221f9f2068a48985fa70b5226" title="Uses complex number multiplication to rotate v1 by v2. Scaling will occur if v1 is not a unit vector.">cpvrotate()</a></code> or <code><a class="el" href="group__cp_vect.html#gac2b1120be08ee9225eadede83f5e054b" title="Inverse of cpvrotate().">cpvunrotate()</a></code> to perform fast rotations. ::: </p><pre class="fragment">&lt;code&gt;cpSpace* cpBodyGetSpace(const cpBody *body)&lt;/code&gt;
</pre><p> ::: expl Get the <code><a class="el" href="structcp_space.html">cpSpace</a></code> that <code>body</code> has been added to. ::: </p><pre class="fragment">&lt;code&gt;cpDataPointer cpBodyGetUserData(const cpBody *body)
void cpBodySetUserData(cpBody *body, const cpDataPointer value)&lt;/code&gt;
</pre><p> ::: expl User data pointer. Use this pointer to get a reference to the game object that owns this body from callbacks. :::</p>
<h2><a class="anchor" id="autotoc_md30"></a>
Moment of Inertia and Area Helper Functions</h2>
<p>Use the following functions to approximate the moment of inertia for your body, adding the results together if you want to use more than one.</p>
<ul>
<li><code>cpFloat <a class="el" href="group__misc.html#gaf1dfe63f43b3dd42e47f37f16ae2dfe4" title="Calculate the moment of inertia for a circle.">cpMomentForCircle(cpFloat m, cpFloat r1, cpFloat r2, cpVect offset)</a></code> - Calculate the moment of inertia for a hollow circle, <code>r1</code> and <code>r2</code> are the inner and outer diameters in no particular order. <em>[]{.0 .of .diameter .inner .an .has .circle .solid .A}</em></li>
<li><code>cpFloat <a class="el" href="group__misc.html#ga1df4d84f2b6ab3cb74d790b55e6a16d4" title="Calculate the moment of inertia for a line segment.">cpMomentForSegment(cpFloat m, cpVect a, cpVect b, cpFloat radius)</a></code> - Calculate the moment of inertia for a line segment. The endpoints <code>a</code> and <code>b</code> are relative to the body.</li>
<li><code>cpFloat <a class="el" href="group__misc.html#ga07f110041cb818aa6c19e41623f5054e" title="Calculate the moment of inertia for a solid polygon shape assuming it&#39;s center of gravity is at it&#39;s ...">cpMomentForPoly(cpFloat m, int count, const cpVect *verts, cpVect offset, cpFloat radius)</a></code> - Calculate the moment of inertia for a solid polygon shape assuming its center of gravity is at its centroid. The offset is added to each vertex.</li>
<li><code>cpFloat <a class="el" href="group__misc.html#gaf7b38a68ad64e02f7542eaab640e6743" title="Calculate the moment of inertia for a solid box.">cpMomentForBox(cpFloat m, cpFloat width, cpFloat height)</a></code> - Calculate the moment of inertia for a solid box centered on the body.</li>
</ul>
<p>&lt;%= pop_open_example "Moments" %&gt;</p>
<p>Use the following functions to get the area for common Chipmunk shapes if you want to approximate masses or density or whatnot.</p>
<ul>
<li><code>cpFloat <a class="el" href="group__misc.html#ga9293a100703445eed36e8673eefe42a1" title="Calculate area of a hollow circle.">cpAreaForCircle(cpFloat r1, cpFloat r2)</a></code> - Area of a hollow circle.</li>
<li><code>cpFloat <a class="el" href="group__misc.html#ga5749ef4558e38005cea36d5eac560ca5" title="Calculate the area of a fattened (capsule shaped) line segment.">cpAreaForSegment(cpVect a, cpVect b, cpFloat r)</a></code> - Area of a beveled segment. <em>[]{.zero .is .radius .if .zero .be .always .Will}</em></li>
<li><code>cpFloat <a class="el" href="group__misc.html#ga916a74d85ac37e3f5577adddad05a0bc" title="Calculate the signed area of a polygon.">cpAreaForPoly(const int count, const cpVect *verts, cpFloat radius)</a></code> - Signed area of a polygon shape. Returns a negative number for polygons with a clockwise winding.</li>
</ul>
<h2><a class="anchor" id="autotoc_md31"></a>
Coordinate Conversion Functions</h2>
<p>Many things are defined in coordinates local to a body meaning that the (0,0) is at the center of gravity of the body and the axis rotate along with the body.</p>
<ul>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_body.html#ga35e470ae1d4c0df38fe7145d029f8399" title="Convert body relative/local coordinates to absolute/world coordinates.">cpBodyLocalToWorld(const cpBody *body, const cpVect v)</a></code> - Convert from body local coordinates to world space coordinates.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_body.html#ga1a098b8788c6d910a8048300ac3f5c77" title="Convert body absolute/world coordinates to relative/local coordinates.">cpBodyWorldToLocal(const cpBody *body, const cpVect v)</a></code> - Convert from world space coordinates to body local coordinates.</li>
</ul>
<h2><a class="anchor" id="autotoc_md32"></a>
Velocity Conversion Functions</h2>
<p>It's often useful to know the absolute velocity of a point on the surface of a body since the angular velocity affects everything except the center of gravity.</p>
<ul>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> cpBodyVelocityAtWorldPoint(const cpBody *body, const point)</code> - Get the absolute velocity of the rigid body at the given world point <code>point</code>.</li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> cpBodyVelocityAtLocalPoint(const cpBody *body, const point)</code> - Get the absolute velocity of the rigid body at the given body local point <code>point</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md33"></a>
Applying Forces and Torques</h2>
<p>People are sometimes confused by the difference between a force and an impulse. An impulse is a very large force applied over a very short period of time. Some examples are a ball hitting a wall or cannon firing. Chipmunk treats impulses as if they occur instantaneously by adding directly to the velocity of an object. Both impulses and forces are affected the mass of an object. Doubling the mass of the object will halve the effect.</p>
<ul>
<li><code>void <a class="el" href="group__cp_body.html#ga94ce4fa01218cbec17338829804c1025" title="Apply a force to a body. Both the force and point are expressed in world coordinates.">cpBodyApplyForceAtWorldPoint(cpBody *body, const cpVect force, const cpVect point)</a></code> - Add the force <code>force</code> to <code>body</code> as if applied from the world point <code>point</code>.</li>
<li><code>void <a class="el" href="group__cp_body.html#ga3441a367681abd6074fa2fe351038c66" title="Apply a force to a body. Both the force and point are expressed in body local coordinates.">cpBodyApplyForceAtLocalPoint(cpBody *body, const cpVect force, const cpVect point)</a></code> - Add the local force <code>force</code> to <code>body</code> as if applied from the body local point <code>point</code>.</li>
<li><code>void <a class="el" href="group__cp_body.html#ga279494c5ddcfd7d76ec23ab7906d99dd" title="Apply an impulse to a body. Both the impulse and point are expressed in world coordinates.">cpBodyApplyImpulseAtWorldPoint(cpBody *body, const cpVect impulse, const cpVect point)</a></code> - Add the impulse <code>impulse</code> to <code>body</code> as if applied from the world point <code>point</code>.</li>
<li><code>void <a class="el" href="group__cp_body.html#ga0bd09fbbf2a3260b7cda569dacec0a33" title="Apply an impulse to a body. Both the impulse and point are expressed in body local coordinates.">cpBodyApplyImpulseAtLocalPoint(cpBody *body, const cpVect impulse, const cpVect point)</a></code> - Add the local impulse <code>impulse</code> to <code>body</code> as if applied from the body local point <code>point</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md34"></a>
Sleeping Functions</h2>
<p>Chipmunk supports a sleeping feature which improves performance by not simulating groups of objects that aren't moving. Read more about it in the cpSpace section.</p>
<ul>
<li><code>cpBool <a class="el" href="group__cp_body.html#ga1bbf47da33d1a2260866f2a257e1b4fa" title="Returns true if the body is sleeping.">cpBodyIsSleeping(const cpBody *body)</a></code> - Returns true if <code>body</code> is sleeping.</li>
<li><code>void <a class="el" href="group__cp_body.html#ga23741f9682e268913d9f6f8a72b64cf0" title="Wake up a sleeping or idle body.">cpBodyActivate(cpBody *body)</a></code> - Reset the idle timer on a body. If it was sleeping, wake it and any other bodies it was touching.</li>
<li><code>void <a class="el" href="group__cp_body.html#gad19cfc0a8e8a96fedf723b165d32a108" title="Force a body to fall asleep immediately.">cpBodySleep(cpBody *body)</a></code> - Forces a body to fall asleep immediately even if it's in midair. Cannot be called from a callback.</li>
<li><code>void <a class="el" href="group__cp_body.html#gabf84834a51b76230ecc83f90890559eb" title="Wake up any sleeping or idle bodies touching a static body.">cpBodyActivateStatic(cpBody *body, cpShape *filter)</a></code> - Similar in function to <code><a class="el" href="group__cp_body.html#ga23741f9682e268913d9f6f8a72b64cf0" title="Wake up a sleeping or idle body.">cpBodyActivate()</a></code>. Activates all bodies touching <code>body</code>. If <code>filter</code> is not <code>NULL</code>, then only bodies touching through <code>filter</code> will be awoken.</li>
</ul>
<pre class="fragment">&lt;code&gt;void cpBodySleepWithGroup(cpBody *body, cpBody *group)&lt;/code&gt;
</pre><p> ::: expl When objects in Chipmunk sleep, they sleep as a group of all objects that are touching or jointed together. When an object is woken up, all of the objects in its group are woken up. <code><a class="el" href="group__cp_body.html#gaae5b2ea3123f996b4db92e63e5f55513" title="Force a body to fall asleep immediately along with other bodies in a group.">cpBodySleepWithGroup()</a></code> allows you group sleeping objects together. It acts identically to <code><a class="el" href="group__cp_body.html#gad19cfc0a8e8a96fedf723b165d32a108" title="Force a body to fall asleep immediately.">cpBodySleep()</a></code> if you pass <code>NULL</code> as <code>group</code> by starting a new group. If you pass a sleeping body for <code>group</code>, <code>body</code> will be awoken when <code>group</code> is awoken. You can use this to initialize levels and start stacks of objects in a pre-sleeping state. :::</p>
<p>&lt;%= pop_open_example "Sleeping" %&gt;</p>
<h2><a class="anchor" id="autotoc_md35"></a>
Iterators</h2>
<pre class="fragment">&lt;code&gt;typedef void (*cpBodyShapeIteratorFunc)(cpBody *body, cpShape *shape, void *data)
void cpBodyEachShape(cpBody *body, cpBodyShapeIteratorFunc func, void *data)&lt;/code&gt;
</pre><p> ::: expl Call <code>func</code> once for each shape that is attached to <code>body</code> and added to a space. <code>data</code> is passed along as a context value. It is safe to remove shapes using these callbacks. ::: </p><pre class="fragment">&lt;code&gt;typedef void (*cpBodyConstraintIteratorFunc)(cpBody *body, cpConstraint *constraint, void *data)
void cpBodyEachConstraint(cpBody *body, cpBodyConstraintIteratorFunc func, void *data)&lt;/code&gt;
</pre><p> ::: expl Call <code>func</code> once for each constraint that is attached to <code>body</code> and added to a space. <code>data</code> is passed along as a context value. It is safe to remove constraints using thes callbacks. ::: </p><pre class="fragment">&lt;code&gt;typedef void (*cpBodyArbiterIteratorFunc)(cpBody *body, cpArbiter *arbiter, void *data)
void cpBodyEachArbiter(cpBody *body, cpBodyArbiterIteratorFunc func, void *data)&lt;/code&gt;
</pre><p> ::: expl This one is more interesting. Calls <code>func</code> once for each collision pair that <code>body</code> is involved in. Calling <code>cpArbiterGet[Bodies|Shapes]()</code> or <code>CP_ARBITER_GET_[BODIES|SHAPES]()</code> will return the body or shape for <code>body</code> as the first argument. You can use this to check all sorts of collision information for a body like if it's touching the ground, another particular object, how much collision force is being applied to an object, etc. Sensor shapes and arbiters that have been rejected by a collision handler callback or <code><a class="el" href="group__cp_arbiter.html#ga7a643cd465bdb61b2f686fdf3558b263" title="Mark a collision pair to be ignored until the two objects separate.">cpArbiterIgnore()</a></code> are not tracked by the contact graph. :::</p>
<p><b>Note:</b> If your compiler supports blocks (such as Clang), there are an alternate set of functions you can call. <code>cpBodyEachShape_b()</code>, etc. See <code><a class="el" href="chipmunk_8h_source.html">chipmunk.h</a></code> for more information.</p>
<p>&lt;%= pop_open_example "Crushing" %&gt;</p>
<h2><a class="anchor" id="autotoc_md36"></a>
Integration Callbacks</h2>
<p>This section is a stub. For now you can look at the Planet demo for an example of how to use integration callbacks to implement planetary gravity.</p>
<h1><a class="anchor" id="autotoc_md37"></a>
Chipmunk Collision Shapes: &lt;tt&gt;cpShape&lt;/tt&gt;</h1>
<p>There are currently 3 collision shape types:</p>
<ul>
<li><b>Circles</b>: Fastest and simplest collision shape.</li>
<li><b>Line segments</b>: Meant mainly as a static shape. Can be beveled in order to give them a thickness.</li>
<li><b>Convex polygons</b>: Slowest, but most flexible collision shape.</li>
</ul>
<p>You can add as many shapes to a body as you wish. That is why the two types are separate. Combining multiple shapes gives you the flexibility to make any object you want as well as providing different areas of the same object with different friction, elasticity or callback values.</p>
<p>When creating different types of shapes, you will always be given a <code>cpShape*</code> pointer back. This is because Chipmunk shapes are meant to be opaque types. Think of the specific collision types such as <code><a class="el" href="structcp_circle_shape.html">cpCircleShape</a></code>, <code><a class="el" href="structcp_segment_shape.html">cpSegmentShape</a></code> and <code><a class="el" href="structcp_poly_shape.html">cpPolyShape</a></code> as private subclasses of <code><a class="el" href="structcp_shape.html">cpShape</a></code>. You can still read some properties from them using the getter functions, but you are not intended to cast <code><a class="el" href="structcp_shape.html">cpShape</a></code> pointers to their specific types.</p>
<h2><a class="anchor" id="autotoc_md38"></a>
Properties</h2>
<p>Chipmunk provides getter/setter functions for a number of properties on collision shapes. Setting most properties will automatically wake the attached rigid body, if it's sleeping. You can also set some of the fields directly on the <a class="el" href="structcp_shape.html">cpShape</a> struct if you wish. They are documented in the headers. </p><pre class="fragment">&lt;code&gt;cpBody * cpShapeGetBody(const cpShape *shape)
void cpShapeSetBody(cpShape *shape, cpBody *body)&lt;/code&gt;
</pre><p> ::: expl The rigid body the shape is attached to. Can only be set when the shape is not added to a space. ::: </p><pre class="fragment">&lt;code&gt;cpBB cpShapeGetBB(const cpShape *shape)&lt;/code&gt;
</pre><p> ::: expl The bounding box of the shape. Only guaranteed to be valid after <code><a class="el" href="group__cp_shape.html#ga899d6f70c74747d4cb52b778447c81e8" title="Update, cache and return the bounding box of a shape based on the body it&#39;s attached to.">cpShapeCacheBB()</a></code> or <code><a class="el" href="group__cp_space.html#gae87c828de2fe3709393ba94046212d80" title="Step the space forward in time by dt.">cpSpaceStep()</a></code> is called. Moving a body that a shape is connected to does not update its bounding box. For shapes used for queries that aren't attached to bodies, you can also use <code><a class="el" href="group__cp_shape.html#gaa3ce1518fb4739b0b4e8964dfb7cd728" title="Update, cache and return the bounding box of a shape with an explicit transformation.">cpShapeUpdate()</a></code>. ::: </p><pre class="fragment">&lt;code&gt;cpBool cpShapeGetSensor(const cpShape *shape)
void cpShapeSetSensor(cpShape *shape, cpBool value)&lt;/code&gt;
</pre><p> ::: expl A boolean value if this shape is a sensor or not. Sensors only call collision callbacks, and never generate real collisions. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpShapeGetElasticity(const cpShape *shape)
void cpShapeSetElasticity(cpShape *shape, cpFloat value)&lt;/code&gt;
</pre><p> ::: expl Elasticity of the shape. A value of 0.0 gives no bounce, while a value of 1.0 will give a "perfect" bounce. However due to inaccuracies in the simulation using 1.0 or greater is not recommended however. The elasticity for a collision is found by multiplying the elasticity of the individual shapes together. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpShapeGetFriction(const cpShape *shape)
void cpShapeSetFriction(cpShape *shape, cpFloat value)&lt;/code&gt;
</pre><p> ::: expl Friction coefficient. Chipmunk uses the Coulomb friction model, a value of 0.0 is frictionless. The friction for a collision is found by multiplying the friction of the individual shapes together. <a href="http://www.roymech.co.uk/Useful_Tables/Tribology/co_of_frict.htm">Tables of friction coefficients</a>. ::: </p><pre class="fragment">&lt;code&gt;cpVect cpShapeGetSurfaceVelocity(const cpShape *shape)
void cpShapeSetSurfaceVelocity(cpShape *shape, cpVect value)&lt;/code&gt;
</pre><p> ::: expl The surface velocity of the object. Useful for creating conveyor belts or players that move around. This value is only used when calculating friction, not resolving the collision. ::: </p><pre class="fragment">&lt;code&gt;cpCollisionType cpShapeGetCollisionType(const cpShape *shape)
void cpShapeSetCollisionType(cpShape *shape, cpCollisionType value)&lt;/code&gt;
</pre><p> ::: expl You can assign types to Chipmunk collision shapes that trigger callbacks when objects of certain types touch. See the callbacks section for more information. ::: </p><pre class="fragment">&lt;code&gt;cpShapeFilter cpShapeGetFilter(const cpShape *shape)
void cpShapeSetFilter(cpShape *shape, cpShapeFilter filter)&lt;/code&gt;
</pre><p> ::: expl Set the collision filter for this shape. See Filtering Collisions for more information. ::: </p><pre class="fragment">&lt;code&gt;cpSpace* cpShapeGetSpace(const cpShape *shape)&lt;/code&gt;
</pre><p> ::: expl Get the <code><a class="el" href="structcp_space.html">cpSpace</a></code> that <code>shape</code> has been added to. ::: </p><pre class="fragment">&lt;code&gt;cpDataPointer cpShapeGetUserData(const cpShape *shape)
void cpShapeSetUserData(cpShape *shape, cpDataPointer value)&lt;/code&gt;
</pre><p> ::: expl A user definable data pointer. If you set this to point at the game object the shapes is for, then you can access your game object from Chipmunk callbacks. :::</p>
<h2><a class="anchor" id="autotoc_md39"></a>
Fast Collision Filtering using cpShapeFilter</h2>
<p>Chipmunk has two primary means of ignoring collisions: groups and category masks.</p>
<p><b>Groups</b> are used to ignore collisions between parts on a complex object. A ragdoll is a good example. When jointing an arm onto the torso, you'll want them to allow them to overlap. Groups allow you to do exactly that. Shapes that have the same group don't generate collisions. So by placing all of the shapes in a ragdoll in the same group, you'll prevent it from colliding against other parts of itself.</p>
<p><b>Category masks</b> allow you to mark which categories an object belongs to and which categories it collidies with.</p>
<p>For example, a game has four collision categories: player (0), enemy (1), player bullet (2), and enemy bullet (3). Neither players nor enemies should not collide with their own bullets, and bullets should not collide with other bullets. However, players collide with enemy bullets, and enemies collide with player bullets.</p>
<hr  />
<p>Object Object Category Category Mask "Player" 1 4, 5 "Enemy" 2 2, 3, 5 "Player
Bullet" 3 1, 5 "Enemy Bullet" 4 2, 5 "Walls" 5 1, 2, 3, 4</p>
<hr  />
<p>Note that everything in this example collides with walls. Additionally, the enemies collide with each other.</p>
<p>By default, objects exist in every category and collide with every category.</p>
<p>Objects can fall into multiple categories. For instance, you might have a category for a red team, and have a red player bullet. In the above example, each object only has one category. If you make use of multiple categories on an object, you may also wish to consider replacing the <code><a class="el" href="structcp_shape_filter.html" title="Fast collision filtering type that is used to determine if two objects collide before calling collisi...">cpShapeFilter</a></code> struct and the <code>cpShapeFilterReject()</code> function in <code><a class="el" href="chipmunk__private_8h_source.html">chipmunk_private.h</a></code> to customize it to better suit your game's needs.</p>
<p>The default type of <code>categories</code> and <code>mask</code> in <code><a class="el" href="structcp_shape_filter.html" title="Fast collision filtering type that is used to determine if two objects collide before calling collisi...">cpShapeFilter</a></code> is <code>unsigned int</code> which has a resolution of 32 bits on most systems. You can redefine <code>cpBitmask</code> in <code><a class="el" href="chipmunk__types_8h_source.html">chipmunk_types.h</a></code> if you need more bits to work with.</p>
<p>There is one last way of filtering collisions using collision handlers. See the section on callbacks for more information. Collision handlers can be more flexible, but can be slower. Fast collision filtering rejects collisions before running the expensive collision detection code, so using groups or category masks is preferred.</p>
<h2><a class="anchor" id="autotoc_md42"></a>
Memory Management Functions</h2>
<pre class="fragment">&lt;code&gt;void cpShapeDestroy(cpShape *shape)
void cpShapeFree(cpShape *shape)&lt;/code&gt;
</pre><p> ::: expl <code>Destroy</code> and <code>Free</code> functions are shared by all shape types. Allocation and initialization functions are specific to each shape type. See below. :::</p>
<h2><a class="anchor" id="autotoc_md43"></a>
Misc Functions</h2>
<ul>
<li><code><a class="el" href="structcp_b_b.html" title="Chipmunk&#39;s axis-aligned 2D bounding box type. (left, bottom, right, top)">cpBB</a> <a class="el" href="group__cp_shape.html#ga899d6f70c74747d4cb52b778447c81e8" title="Update, cache and return the bounding box of a shape based on the body it&#39;s attached to.">cpShapeCacheBB(cpShape *shape)</a></code> - Synchronizes <code>shape</code> with the body its attached to.</li>
<li><code><a class="el" href="structcp_b_b.html" title="Chipmunk&#39;s axis-aligned 2D bounding box type. (left, bottom, right, top)">cpBB</a> cpShapeUpdate(cpShape *shape, cpVect pos, cpVect rot)</code> - Sets the position and rotation of the shape to</li>
</ul>
<h2><a class="anchor" id="autotoc_md44"></a>
Working With Circle Shapes</h2>
<pre class="fragment">&lt;code&gt;cpCircleShape *cpCircleShapeAlloc(void)
cpCircleShape *cpCircleShapeInit(cpCircleShape *circle, cpBody *body, cpFloat radius, cpVect offset)
cpShape *cpCircleShapeNew(cpBody *body, cpFloat radius, cpVect offset)&lt;/code&gt;
</pre><p> ::: expl <code>body</code> is the body to attach the circle to, <code>offset</code> is the offset from the body's center of gravity in body local coordinates. ::: </p><pre class="fragment">&lt;code&gt;cpVect cpCircleShapeGetOffset(cpShape *circleShape)
cpFloat cpCircleShapeGetRadius(cpShape *circleShape)&lt;/code&gt;
</pre><p> ::: expl Getters for circle shape properties. Passing as non-circle shape will throw an assertion. :::</p>
<h2><a class="anchor" id="autotoc_md45"></a>
Working With Segment Shapes</h2>
<pre class="fragment">&lt;code&gt;cpSegmentShape* cpSegmentShapeAlloc(void)
cpSegmentShape* cpSegmentShapeInit(cpSegmentShape *seg, cpBody *body, cpVect a, cpVect b, cpFloat radius)
cpShape* cpSegmentShapeNew(cpBody *body, cpVect a, cpVect b, cpFloat radius)&lt;/code&gt;
</pre><p> ::: expl <code>body</code> is the body to attach the segment to, <code>a</code> and <code>b</code> are the endpoints, and <code>radius</code> is the thickness of the segment. ::: </p><pre class="fragment">&lt;code&gt;cpVect cpSegmentShapeGetA(cpShape *shape)
cpVect cpSegmentShapeGetB(cpShape *shape)
cpVect cpSegmentShapeGetNormal(cpShape *shape)
cpFloat cpSegmentShapeGetRadius(cpShape *shape)&lt;/code&gt;
</pre><p> ::: expl Getters for segment shape properties. Passing a non-segment shape will throw an assertion. ::: </p><pre class="fragment">&lt;code&gt;void cpSegmentShapeSetNeighbors(cpShape *shape, cpVect prev, cpVect next)&lt;/code&gt;
</pre><p> ::: expl When you have a number of segment shapes that are all joined together, things can still collide with the "cracks" between the segments. By setting the neighbor segment endpoints you can tell Chipmunk to avoid colliding with the inner parts of the crack. :::</p>
<h2><a class="anchor" id="autotoc_md46"></a>
Working With Polygon Shapes</h2>
<pre class="fragment">&lt;code&gt;cpPolyShape *cpPolyShapeAlloc(void)

cpPolyShape *cpPolyShapeInit(cpPolyShape *poly, cpBody *body, int count, const cpVect *verts, cpTransform transform, cpFloat radius)
cpShape *cpPolyShapeNew(cpBody *body, int numVerts, cpVect *verts, cpTransform transform, cpFloat radius)&lt;/code&gt;
</pre><p> \ p(expl). <code>body</code> is the body to attach the poly to, <code>verts</code> is an array of <code><a class="el" href="structcp_vect.html">cpVect</a></code> structs, <code>transform</code> will be applied to every vertex. A convex hull will be calculated from the vertexes automatically.\ The polygon shape will be created with a <code>radius</code>, increasing the size of the shape. </p><pre class="fragment">&lt;code&gt;cpPolyShape* cpPolyShapeInitRaw(cpPolyShape *poly, cpBody *body, int count, const cpVect *verts, cpFloat radius)
cpShape* cpPolyShapeNewRaw(cpBody *body, int count, const cpVect *verts, cpFloat radius)&lt;/code&gt;
</pre><p> Alternate constructors for poly shapes. This version does not apply a transform nor does it create a convex hull. Vertices <em>must</em> be provided with a counter-clockwise winding. </p><pre class="fragment">&lt;code&gt;int cpPolyShapeGetCount(cpShape *shape)
cpVect cpPolyShapeGetVert(cpShape *shape, int index)
cpFloat cpPolyShapeGetRadius()&lt;/code&gt;
</pre><p> ::: expl Getters for poly shape properties. Passing a non-poly shape or an index that does not exist will throw an assertion. :::</p>
<h3><a class="anchor" id="autotoc_md47"></a>
Boxes</h3>
<p>Because boxes are so common in physics games, Chipmunk provides shortcuts to create box shaped polygons. The boxes will always be centered at the center of gravity of the body you are attaching them to. Adding a small radius will bevel the corners and can significantly reduce problems where the box gets stuck on seams in your geometry. If you want to create an off-center box, you will need to use <code><a class="el" href="group__cp_poly_shape.html#gaed41237141b0ef9066117a829bfce9e0" title="Allocate and initialize a polygon shape with rounded corners.">cpPolyShapeNew()</a></code> or <code><a class="el" href="group__cp_poly_shape.html#ga8f30c48538498234bed45abc3c16b80d" title="Initialize a polygon shape with rounded corners.">cpPolyShapeInit()</a></code>. </p><pre class="fragment">&lt;code&gt;cpPolyShape *cpBoxShapeInit(cpPolyShape *poly, cpBody *body, cpFloat width, cpFloat height, cpFloat radius)
cpPolyShape *cpBoxShapeInit2(cpPolyShape *poly, cpBody *body, cpBB box, cpFloat radius)

cpShape *cpBoxShapeNew(cpBody *body, cpFloat width, cpFloat height, cpFloat radius)
cpShape *cpBoxShapeNew2(cpBody *body, cpBB box, cpFloat radius)&lt;/code&gt;
</pre> <h3><a class="anchor" id="autotoc_md48"></a>
Poly Shape Helper Functions</h3>
<ul>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__misc.html#gaaeaa99c27ff452c3bb957cf3d82d4f64" title="Calculate the natural centroid of a polygon.">cpCentroidForPoly(const int count, const cpVect *verts)</a></code> - Calculate the centroid for a polygon.</li>
</ul>
<h3><a class="anchor" id="autotoc_md49"></a>
Convex Hull Helper Functions</h3>
<pre class="fragment">&lt;code&gt;int cpConvexHull(int count, cpVect *verts, cpVect *result, int *first, cpFloat tol)&lt;/code&gt;
</pre><p> ::: expl Calculate the convex hull of a given set of points. Returns the count of points in the hull. <code>result</code> must be a pointer to a <code><a class="el" href="structcp_vect.html">cpVect</a></code> array with at least <code>count</code> elements. If <code>result</code> is <code>NULL</code>, then <code>verts</code> array wil be reduced instead. <code>first</code> is an optional pointer to an integer to store where the first vertex in the hull came from (i.e. <code>verts[first] == result[0]</code>) <code>tol</code> is the allowed amount to shrink the hull when simplifying it. A tolerance of 0.0 creates an exact hull. ::: </p><pre class="fragment">&lt;code&gt;#define CP_CONVEX_HULL(inputCount, inputVerts, outputCount_varName, outputVerts_varName)&lt;/code&gt;
</pre><p> ::: expl Convenience macro for using <code><a class="el" href="group__misc.html#ga4468d521319fa699354b8d0e1d9532fe" title="Calculate the convex hull of a given set of points.">cpConvexHull()</a></code>. Creates an array on the stack using <code>alloca()</code> and then calls <code><a class="el" href="group__misc.html#ga4468d521319fa699354b8d0e1d9532fe" title="Calculate the convex hull of a given set of points.">cpConvexHull()</a></code>. Because the output array is created on the stack it doesn't need to be freed. :::</p>
<p>&lt;%= pop_open_example "cpConvexHull" %&gt;</p>
<h2><a class="anchor" id="autotoc_md50"></a>
Modifying cpShapes</h2>
<p>The short answer is that you can't because the changes would be only picked up as a change to the position of the shape's surface, but not its velocity. The long answer is that you can using the "unsafe" API as long as you realize that doing so will result in unrealistic physical behavior. These extra functions are defined in a separate header <code><a class="el" href="chipmunk__unsafe_8h_source.html">chipmunk_unsafe.h</a></code>.</p>
<h2><a class="anchor" id="autotoc_md51"></a>
Notes</h2>
<ul>
<li>You can attach multiple collision shapes to a rigid body. This should allow you to create almost any shape you could possibly need.</li>
<li>Shapes attached to the same rigid body will never generate collisions. You don't have to worry about overlap when attaching multiple shapes to a rigid body.</li>
<li>Make sure you add both the body and its collision shapes to a space.</li>
</ul>
<h1><a class="anchor" id="autotoc_md52"></a>
Chipmunk Spaces: &lt;tt&gt;cpSpace&lt;/tt&gt;</h1>
<p>Spaces in Chipmunk are the basic unit of simulation. You add rigid bodies, shapes, and constraints to the space and then step them all forward through time together.</p>
<h2><a class="anchor" id="autotoc_md53"></a>
What Are Iterations, and Why Should I Care?</h2>
<p>Chipmunk uses an iterative solver to figure out the forces between objects in the space. What this means is that it builds a big list of all the collisions, joints, and other constraints between the bodies and makes several passes over the list considering each one individually. The number of passes it makes is the iteration count, and each iteration makes the solution more accurate. If you use too many iterations, the physics should look nice and solid, but may use up too much CPU time. If you use too few iterations, the simulation may seem mushy or bouncy when the objects should be solid. Setting the number of iterations lets you balance between CPU usage and the accuracy of the physics. Chipmunk's default of 10 iterations is sufficient for most simple games.</p>
<h2><a class="anchor" id="autotoc_md54"></a>
Sleeping</h2>
<p>Spaces can disable entire groups of objects that have stopped moving to save CPU time and battery life. In order to use this feature you must do two things. You must enable sleeping explicitly by choosing a time threshold value for <code>cpSpace.sleepTimeThreshold</code>. This threshold is the amount of time something must be idle before it falls asleep. <code>cpSpace.idleSpeedThreshold</code> defines what is considered idle. If you do not set <code>cpSpace.idleSpeedThreshold</code> explicitly, a value will be chosen automatically based on the current amount of gravity. Be mindful that objects cannot fall asleep if they are touching or jointed to a kinematic body.</p>
<h2><a class="anchor" id="autotoc_md55"></a>
Properties</h2>
<pre class="fragment">&lt;code&gt;int cpSpaceGetIterations(const cpSpace *space)
void cpSpaceSetIterations(cpSpace *space, int value)&lt;/code&gt;
</pre><p> ::: expl Iterations allow you to control the accuracy of the solver. Defaults to 10. See above for more information. ::: </p><pre class="fragment">&lt;code&gt;cpVect cpSpaceGetGravity(const cpSpace *space)
void cpSpaceSetGravity(cpSpace *space, cpVect value)&lt;/code&gt;
</pre><p> ::: expl Global gravity applied to the space. Defaults to <code>cpvzero</code>. Can be overridden on a per body basis by writing custom integration functions. Changing the gravity will activate all sleeping bodies in the space. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpSpaceGetDamping(const cpSpace *space)
void cpSpaceSetDamping(cpSpace *space, cpFloat value)&lt;/code&gt;
</pre><p> ::: expl Amount of simple damping to apply to the space. A value of 0.9 means that each body will lose 10% of its velocity per second. Defaults to 1. Like <code>gravity</code>, it can be overridden on a per body basis. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpSpaceGetIdleSpeedThreshold(const cpSpace *space)
void cpSpaceSetIdleSpeedThreshold(cpSpace *space, cpFloat value)&lt;/code&gt;
</pre><p> ::: expl Speed threshold for a body to be considered idle. The default value of 0 means the space estimates a good threshold based on gravity. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpSpaceGetSleepTimeThreshold(const cpSpace *space)
void cpSpaceSetSleepTimeThreshold(cpSpace *space, cpFloat value)&lt;/code&gt;
</pre><p> ::: expl Time a group of bodies must remain idle in order to fall asleep. The default value of <code>INFINITY</code> disables the sleeping feature. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpSpaceGetCollisionSlop(const cpSpace *space)
void cpSpaceSetCollisionSlop(cpSpace *space, cpFloat value)&lt;/code&gt;
</pre><p> ::: expl Amount of overlap between shapes that is allowed. To improve stability, set this as high as you can without noticable overlapping. It defaults to 0.1. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpSpaceGetCollisionBias(const cpSpace *space)
void cpSpaceSetCollisionBias(cpSpace *space, cpFloat value)&lt;/code&gt;
</pre><p> ::: expl Chipmunk allows fast moving objects to overlap, then fixes the overlap over time. Overlapping objects are unavoidable even if swept collisions are supported, and this is an efficient and stable way to deal with overlapping objects. The bias value controls what percentage of overlap remains unfixed after a second and defaults to0.2%. Valid values are in the range from 0 to 1, but using 0 is not recommended for stability reasons. The default value is calculated as <code>cpfpow(1.0f - 0.1f, 60.0f)</code> meaning that Chipmunk attempts to correct 10% of error ever 1/60th of a second. <b>Note:</b> Very, very few games will need to change this value. ::: </p><pre class="fragment">&lt;code&gt;cpTimestamp cpSpaceGetCollisionPersistence(const cpSpace *space)
void cpSpaceSetCollisionPersistence(cpSpace *space, cpTimestamp value)&lt;/code&gt;
</pre><p> ::: expl The number of frames the space keeps collision solutions around for. Helps prevent jittering contacts from getting worse. This defaults to 3 and very very <em>very</em> few games will need to change this value. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpSpaceGetCurrentTimeStep(const cpSpace *space)&lt;/code&gt;
</pre><p> ::: expl Retrieves the current (if you are in a callback from <code><a class="el" href="group__cp_space.html#gae87c828de2fe3709393ba94046212d80" title="Step the space forward in time by dt.">cpSpaceStep()</a></code>) or most recent (outside of a <code><a class="el" href="group__cp_space.html#gae87c828de2fe3709393ba94046212d80" title="Step the space forward in time by dt.">cpSpaceStep()</a></code> call) timestep. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpSpaceIsLocked(const cpSpace *space)&lt;/code&gt;
</pre><p> ::: expl Returns true when you cannot add/remove objects from the space. In particular, spaces are locked when in a collision callback. Instead, run your code in a post-step callback instead. ::: </p><pre class="fragment">&lt;code&gt;cpDataPointer cpSpaceGetUserData(const cpSpace *space)
void cpSpaceSetUserData(cpSpace *space, cpDataPointer value)&lt;/code&gt;
</pre><p> ::: expl A user definable data pointer. It is often useful to point this at the game state object or scene management object that owns the space. ::: </p><pre class="fragment">&lt;code&gt;cpBody * cpSpaceGetStaticBody(const cpSpace *space)&lt;/code&gt;
</pre><p> ::: expl A dedicated static body for the space. You don't have to use it, but because its memory is managed automatically with the space its very convenient. You can set its user data pointer to something helpful if you want for callbacks. :::</p>
<h2><a class="anchor" id="autotoc_md56"></a>
Memory Management Functions</h2>
<pre class="fragment">&lt;code&gt;cpSpace* cpSpaceAlloc(void)
cpSpace* cpSpaceInit(cpSpace *space)
cpSpace* cpSpaceNew()

void cpSpaceDestroy(cpSpace *space)
void cpSpaceFree(cpSpace *space)&lt;/code&gt;
</pre><p> ::: expl More standard Chipmunk memory functions. :::</p>
<h2><a class="anchor" id="autotoc_md57"></a>
Operations</h2>
<pre class="fragment">&lt;code&gt;cpShape *cpSpaceAddShape(cpSpace *space, cpShape *shape)
cpBody *cpSpaceAddBody(cpSpace *space, cpBody *body)
cpConstraint *cpSpaceAddConstraint(cpSpace *space, cpConstraint *constraint)

void cpSpaceRemoveShape(cpSpace *space, cpShape *shape)
void cpSpaceRemoveBody(cpSpace *space, cpBody *body)
void cpSpaceRemoveConstraint(cpSpace *space, cpConstraint *constraint)

cpBool cpSpaceContainsShape(cpSpace *space, cpShape *shape)
cpBool cpSpaceContainsBody(cpSpace *space, cpBody *body)
cpBool cpSpaceContainsConstraint(cpSpace *space, cpConstraint *constraint)&lt;/code&gt;
</pre><p> ::: expl These functions add and remove shapes, bodies and constraints from <code>space</code>. The add/remove functions cannot be called from within a callback other than a <code>postStep()</code> callback _(which is different than a postSolve() callback!)_. Attempting to add or remove objects from the space while <code><a class="el" href="group__cp_space.html#gae87c828de2fe3709393ba94046212d80" title="Step the space forward in time by dt.">cpSpaceStep()</a></code> is still executing will throw an assertion. See the callbacks section for more information. The add functions return the thing being added so that you can create and add something in one line. Be careful not to free bodies before removing shapes and constraints attached to them or you will cause crashes.. The contains functions allow you to check if an object has been added to the space or not. :::</p>
<h2><a class="anchor" id="autotoc_md58"></a>
Spatial Indexing</h2>
<p>Occasionally, you might want to update the collision detection data for a shape. If you move a static shape or a static body you <b>must</b> do this to let Chipmunk know it needs to have its collision detection data updated. You may also want to manually update the collision data for normal shapes if you move them and still want to perform queries against them before the next call to <code><a class="el" href="group__cp_space.html#gae87c828de2fe3709393ba94046212d80" title="Step the space forward in time by dt.">cpSpaceStep()</a></code>.</p>
<ul>
<li><code>void <a class="el" href="group__cp_space.html#gab370e5ee7912ff798bebeb01fc0ba63b" title="Update the collision detection data for a specific shape in the space.">cpSpaceReindexShape(cpSpace *space, cpShape *shape)</a></code> - Reindex a specific shape.</li>
<li><code>void <a class="el" href="group__cp_space.html#ga9a141b9c927102b02a84bb2b8631f803" title="Update the collision detection data for all shapes attached to a body.">cpSpaceReindexShapesForBody(cpSpace *space, cpBody *body)</a></code> - Reindex all the shapes for a certain body.</li>
<li><code>void <a class="el" href="group__cp_space.html#ga714f105c977f9006128981fa30d8e7ec" title="Update the collision detection info for the static shapes in the space.">cpSpaceReindexStatic(cpSpace *space)</a></code> - Reindex all static shapes. Generally updating only the shapes that changed is faster.</li>
</ul>
<h2><a class="anchor" id="autotoc_md59"></a>
Iterators</h2>
<pre class="fragment">&lt;code&gt;typedef void (*cpSpaceBodyIteratorFunc)(cpBody *body, void *data)
void cpSpaceEachBody(cpSpace *space, cpSpaceBodyIteratorFunc func, void *data)&lt;/code&gt;
</pre><p> ::: expl Call <code>func</code> for each body in the space also passing along your data pointer. Sleeping bodies are included, but static and kinematic bodies are not as they aren't added to the space. :::</p>
<p>&lt;%= pop_open_example "cpSpaceEachBody" %&gt; </p><pre class="fragment">&lt;code&gt;typedef void (*cpSpaceShapeIteratorFunc)(cpShape *shape, void *data)
void cpSpaceEachShape(cpSpace *space, cpSpaceShapeIteratorFunc func, void *data)&lt;/code&gt;
</pre><p> ::: expl Call <code>func</code> for each shape in the space also passing along your data pointer. Sleeping and static shapes are included. ::: </p><pre class="fragment">&lt;code&gt;typedef void (*cpSpaceConstraintIteratorFunc)(cpConstraint *constraint, void *data)
void cpSpaceEachConstraint(cpSpace *space, cpSpaceConstraintIteratorFunc func, void *data)&lt;/code&gt;
</pre><p> ::: expl Call <code>func</code> for each constraint in the space also passing along your data pointer. :::</p>
<p><b>Note:</b> If your compiler supports blocks (such as Clang), there are an alternate set of functions you can call. <code>cpSpaceEachBody_b()</code>, etc. See <code><a class="el" href="chipmunk_8h_source.html">chipmunk.h</a></code> for more information.</p>
<h2><a class="anchor" id="autotoc_md60"></a>
Simulating the Space</h2>
<pre class="fragment">&lt;code&gt;void cpSpaceStep(cpSpace *space, cpFloat dt)&lt;/code&gt;
</pre><p> ::: expl Update the space for the given time step. Using a fixed time step is <em>highly</em> recommended. Doing so can greatly increase the quality of the simulation. The easiest way to do constant timesteps is to simple step forward by 1/60th of a second (or whatever your target framerate is) for each frame regardless of how long it took to render. This works fine for many games, but a better way to do it is to separate your physics timestep and rendering. <a href="http://gafferongames.com/game-physics/fix-your-timestep/">This</a> is a good article on how to do that. :::</p>
<h2><a class="anchor" id="autotoc_md61"></a>
Enabling and Tuning the Spatial Hash</h2>
<p>Chipmunk officially supports two spatial indexes. The default is an axis-aligned bounding box tree inspired by the one used in the Bullet Physics library, but caching of overlapping leaves was added to give it very good temporal coherence. The tree requires no tuning, and most games will find that they get the best performance using from the tree. The other available spatial index type available is a spatial hash, which can be much faster when you have a very large number (1000s) of objects that are all the same size. For smaller numbers of objects, or objects that vary a lot in size, the spatial hash is usually much slower. It also requires tuning (usually through experimentation) to get the best possible performance. </p><pre class="fragment">&lt;code&gt;void cpSpaceUseSpatialHash(cpSpace *space, cpFloat dim, int count)&lt;/code&gt;
</pre><p> ::: expl Switch the space to use a spatial hash instead of the bounding box tree. :::</p>
<p>The spatial hash data is fairly size sensitive. <code>dim</code> is the size of the hash cells. Setting <code>dim</code> to the average collision shape size is likely to give the best performance. Setting <code>dim</code> too small will cause the shape to be inserted into many cells, setting it too low will cause too many objects into the same hash slot.</p>
<p><code>count</code> is the <em>suggested</em> minimum number of cells in the hash table. If there are too few cells, the spatial hash will return many false positives. Too many cells will be hard on the cache and waste memory. The Setting <code>count</code> to10x the number of objects in the space is probably a good starting point. Tune from there if necessary.</p>
<p>Using the spatial has visualization in the demo program you can see what I mean. The grey squares represent cells in the spatial hash. The darker the cell, the more objects have been mapped into that cell. A good <code>dim</code> size is when your objects fit nicely into the grid:</p>
<p><img src="images/hash_just_right.png" alt="" class="inline"/></p>
<p>Notice the light grey meaning that each cell doesn't have too many objects mapped onto it.</p>
<p>When you use too small a size, Chipmunk has to insert each object into a lot of cells. This can get expensive.</p>
<p><img src="images/hash_too_small.png" alt="" class="inline"/></p>
<p>Notice that the grey cells are very small compared to the collision shapes.</p>
<p>When you use too big of a size, a lot of shapes will fit into each cell. Each shape has to be checked against every other shape in the cell, so this makes for a lot of unnecessary collision checks.</p>
<p><img src="images/hash_too_big.png" alt="" class="inline"/></p>
<p>Notice the dark grey cells meaning that many objects are mapped onto them.</p>
<p>Chipmunk also has an experimental single axis sort and sweep implementation. It can be very efficient on mobile games if your world is very long and flat like a racing game. See the code for <code><a class="el" href="group__cp_space.html#gaed394ccafade6346f25e9c78f92bc185" title="Switch the space to use a spatial has as it&#39;s spatial index.">cpSpaceUseSpatialHash()</a></code> if you want to try enabling it.</p>
<h2><a class="anchor" id="autotoc_md62"></a>
Notes</h2>
<ul>
<li>When removing objects from the space, make sure you remove any other objects that reference it. For instance, when you remove a body, remove the joints and shapes attached to it.</li>
<li>Using more iterations or smaller time steps will increase the physics quality, but also increase the CPU usage.</li>
<li>Because static shapes are only rehashed when you request it, TODO: cpSpaceHashResize</li>
</ul>
<h1><a class="anchor" id="autotoc_md63"></a>
Chipmunk Constraints: &lt;tt&gt;cpConstraint&lt;/tt&gt;</h1>
<p>A constraint is something that describes how two bodies interact with each other. (how they constrain each other) Constraints can be simple joints that allow bodies to pivot around each other like the bones in your body, or they can be more abstract like the gear joint or motors.</p>
<h2><a class="anchor" id="autotoc_md64"></a>
What constraints are and what they are not</h2>
<p>Constraints in Chipmunk are all velocity based constraints. This means that they act primarily by synchronizing the velocity of two bodies. A pivot joint holds two anchor points on two separate bodies together by defining equations that say that the velocity of the anchor points must be the same and calculating impulses to apply to the bodies to try and keep it that way. A constraint takes a velocity as it's primary input and produces a velocity change as its output. Some constraints, (joints in particular) apply velocity changes to correct differences in positions. More about this in the next section.</p>
<p>A spring connected between two bodies is not a constraint. It's very constraint-like as it creates forces that affect the velocities of the two bodies, but a spring takes distances as input and produces forces as its output. If a spring is not a constraint, then why do I have two varieties of spring constraints you ask? The reason is that they are <em>damped springs</em>. The damping associated with the spring is a true constraint that creates velocity changes based on the relative velocities of the two bodies it links. As it is convenient to put a damper and a spring together most of the time, I figured I might as well just apply the spring force as part of the constraint instead of having a damper constraint and having the user calculate and apply their own spring forces separately.</p>
<h2><a class="anchor" id="autotoc_md65"></a>
Properties</h2>
<pre class="fragment">&lt;code&gt;cpBody * cpConstraintGetA(const cpConstraint *constraint)
cpBody * cpConstraintGetB(const cpConstraint *constraint)&lt;/code&gt;
</pre><p> ::: expl Getters for the two bodies the constraint is attached to. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpConstraintGetMaxForce(const cpConstraint *constraint)
void cpConstraintSetMaxForce(cpConstraint *constraint, cpFloat value)&lt;/code&gt;
</pre><p> ::: expl The maximum force that the constraint can use to act on the two bodies. Defaults to INFINITY. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpConstraintGetErrorBias(const cpConstraint *constraint)
void cpConstraintSetErrorBias(cpConstraint *constraint, cpFloat value)&lt;/code&gt;
</pre><p> ::: expl The percentage of joint error that remains unfixed after a second. This works exactly the same as the collision bias property of a space, but applies to fixing error (stretching) of joints instead of overlapping collisions. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpConstraintGetMaxBias(const cpConstraint *constraint)
void cpConstraintSetMaxBias(cpConstraint *constraint, cpFloat value)&lt;/code&gt;
</pre><p> ::: expl The maximum speed at which the constraint can apply error correction. Defaults to INFINITY. ::: </p><pre class="fragment">&lt;code&gt;cpSpace* cpConstraintGetSpace(const cpConstraint *constraint)&lt;/code&gt;
</pre><p> ::: expl Get the <code><a class="el" href="structcp_space.html">cpSpace</a></code> that <code>constraint</code> has been added to. ::: </p><pre class="fragment">&lt;code&gt;cpBool cpConstraintGetCollideBodies(const cpConstraint *constraint)
void cpConstraintSetCollideBodies(cpConstraint *constraint, cpBool collideBodies)&lt;/code&gt;
</pre><p> ::: expl Constraints can be used for filtering collisions too. When two bodies collide, Chipmunk ignores the collisions if this property is set to <code>cpFalse</code> on any constraint that connects the two bodies. Defaults to <code>cpTrue</code>. This can be used to create a chain that self collides, but adjacent links in the chain do not collide. ::: </p><pre class="fragment">&lt;code&gt;cpDataPointer cpConstraintGetUserData(const cpConstraint *constraint)
void cpConstraintSetUserData(cpConstraint *constraint, cpDataPointer value)&lt;/code&gt;
</pre><p> ::: expl User data pointer. Use this pointer to get a reference to the game object that owns this constraint from callbacks. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpConstraintGetImpulse(cpConstraint *constraint)&lt;/code&gt;
</pre><p> ::: expl The most recent impulse that <code>constraint</code> applied. To convert this to a force, divide by the timestep passed to <code><a class="el" href="group__cp_space.html#gae87c828de2fe3709393ba94046212d80" title="Step the space forward in time by dt.">cpSpaceStep()</a></code>. You can use this to implement breakable joints to check if the force they attempted to apply exceeded a certain threshold. :::</p>
<p>&lt;%= pop_open_example "BreakableJoint" %&gt;</p>
<p>To access properties of specific joint types, use the getter and setter functions provided (ex: <code>cpPinJointGetanchorA()</code>). See the lists of properties for more information.</p>
<h2><a class="anchor" id="autotoc_md66"></a>
Error correction by Feedback</h2>
<p>Joints in Chipmunk are not perfect. A pin joint can't maintain the exact correct distance between its anchor points, nor can a pivot joint hold its anchor points completely together. Instead, they are designed to deal with this by correcting themselves over time. Since Chipmunk 5, you have a fair amount of extra control over how joints correct themselves and can even use this ability to create physical effects that allow you to use joints in unique ways:</p>
<ul>
<li>Servo motors - Ex: open/close doors or rotate things without going over a maximum force.</li>
<li>Winches - Pull one object towards another at a constant speed without going over a maximum force.</li>
<li>Mouse manipulation - Interact with objects smoothly given coarse/shaky mouse input.</li>
</ul>
<p>There are three properties of <a class="el" href="structcp_constraint.html">cpConstraint</a> structs that control the error correction, <code>maxForce</code>, <code>maxBias</code>, and <code>biasCoef</code>. <code>maxForce</code> is pretty self explanatory, a joint or constraint will not be able to use more than this amount of force in order to function. If it needs more force to be able to hold itself together, it will fall apart. <code>maxBias</code> is the maximum speed at which error correction can be applied. If you change a property on a joint so that the joint will have to correct itself, it normally does so very quickly. By setting a maxSpeed you can make the joint work like a servo, correcting itself at a constant rate over a longer period of time. Lastly, <code>biasCoef</code> is the percentage of error corrected every step before clamping to a maximum speed. You can use this to make joints correct themselves smoothly instead of at a constant speed, but is probably the least useful of the three properties by far.</p>
<p>&lt;%= pop_open_example "JointRecipies" %&gt;</p>
<h2><a class="anchor" id="autotoc_md67"></a>
Constraints and Collision Shapes</h2>
<p>Neither constraints or collision shapes have any knowledge of the other. When connecting joints to a body the anchor points don't need to be inside of any shapes attached to the body and it often makes sense that they shouldn't. Also, adding a constraint between two bodies doesn't prevent their collision shapes from colliding. In fact, this is the primary reason that the collision group property exists.</p>
<h2><a class="anchor" id="autotoc_md68"></a>
Video Tour of Current Joint Types. (Requires connection to YouTube)</h2>
<p>&lt;object width="425" height="344"&gt;</p>
<p><code>&lt;param name="movie" value="http://www.youtube.com/v/ZgJJZTS0aMM&amp;amp;hl=en_US&amp;amp;fs=1?rel=0"&gt;</code>{=html}<code>&lt;/param&gt;</code>{=html}<code>&lt;param name="allowFullScreen" value="true"&gt;</code>{=html}<code>&lt;/param&gt;</code>{=html}<code>&lt;param name="allowscriptaccess" value="always"&gt;</code>{=html}<code>&lt;/param&gt;</code>{=html}<code>&lt;embed src="http://www.youtube.com/v/ZgJJZTS0aMM&amp;amp;hl=en_US&amp;amp;fs=1?rel=0" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="425" height="344"&gt;</code>{=html}<code>&lt;/embed&gt;</code>{=html}<code>&lt;/object&gt;</code>{=html}</p>
<h2><a class="anchor" id="autotoc_md69"></a>
Shared Memory Management Functions</h2>
<pre class="fragment">&lt;code&gt;void cpConstraintDestroy(cpConstraint *constraint)
void cpConstraintFree(cpConstraint *constraint)&lt;/code&gt;
</pre><p> ::: expl <code>Destroy</code> and <code>Free</code> functions are shared by all joint types. Allocation and initialization functions are specific to each joint type. :::</p>
<h1><a class="anchor" id="autotoc_md70"></a>
Constraint Types</h1>
<h2><a class="anchor" id="autotoc_md71"></a>
Pin Joints</h2>
<pre class="fragment">&lt;code&gt;cpPinJoint *cpPinJointAlloc(void)
cpPinJoint *cpPinJointInit(cpPinJoint *joint, cpBody *a, cpBody *b, cpVect anchorA, cpVect anchorB)
cpConstraint *cpPinJointNew(cpBody *a, cpBody *b, cpVect anchorA, cpVect anchorB)&lt;/code&gt;
</pre><p> ::: expl <code>a</code> and <code>b</code> are the two bodies to connect, and <code>anchorA</code> and <code>anchorB</code> are the anchor points on those bodies. The distance between the two anchor points is measured when the joint is created. If you want to set a specific distance, use the setter function to override it. :::</p>
<h3><a class="anchor" id="autotoc_md72"></a>
Properties</h3>
<ul>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> cpPinJointGetanchorA(const cpConstraint *constraint)</code></li>
<li><code>void cpPinJointSetanchorA(cpConstraint *constraint, cpVect value)</code></li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> cpPinJointGetanchorB(const cpConstraint *constraint)</code></li>
<li><code>void cpPinJointSetanchorB(cpConstraint *constraint, cpVect value)</code></li>
<li><code>cpFloat <a class="el" href="group__cp_pin_joint.html#ga65f2f893e5949242075cf2e0c17874dd" title="Get the distance the joint will maintain between the two anchors.">cpPinJointGetDist(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_pin_joint.html#gaa83a79c929128035c6d47125d60f797b" title="Set the distance the joint will maintain between the two anchors.">cpPinJointSetDist(cpConstraint *constraint, cpFloat value)</a></code></li>
</ul>
<h2><a class="anchor" id="autotoc_md73"></a>
Slide Joints</h2>
<pre class="fragment">&lt;code&gt;cpSlideJoint *cpSlideJointAlloc(void)

cpSlideJoint *cpSlideJointInit(
    cpSlideJoint *joint, cpBody *a, cpBody *b,
    cpVect anchorA, cpVect anchorB, cpFloat min, cpFloat max
)

cpConstraint *cpSlideJointNew(cpBody *a, cpBody *b, cpVect anchorA, cpVect anchorB, cpFloat min, cpFloat max)&lt;/code&gt;
</pre><p> ::: expl <code>a</code> and <code>b</code> are the two bodies to connect, <code>anchorA</code> and <code>anchorB</code> are the anchor points on those bodies, and <code>min</code> and <code>max</code> define the allowed distances of the anchor points. :::</p>
<h3><a class="anchor" id="autotoc_md74"></a>
Properties</h3>
<ul>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> cpSlideJointGetanchorA(const cpConstraint *constraint)</code></li>
<li><code>void cpSlideJointSetanchorA(cpConstraint *constraint, cpVect value)</code></li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> cpSlideJointGetanchorB(const cpConstraint *constraint)</code></li>
<li><code>void cpSlideJointSetanchorB(cpConstraint *constraint, cpVect value)</code></li>
<li><code>cpFloat <a class="el" href="group__cp_slide_joint.html#gaa3e2239ae46655548ecd29d9fe6b23f9" title="Get the minimum distance the joint will maintain between the two anchors.">cpSlideJointGetMin(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_slide_joint.html#ga67df01ba84cfc0897884e241c8337110" title="Set the minimum distance the joint will maintain between the two anchors.">cpSlideJointSetMin(cpConstraint *constraint, cpFloat value)</a></code></li>
<li><code>cpFloat <a class="el" href="group__cp_slide_joint.html#ga6c6b89b775f61ac58aa37608869a35c7" title="Get the maximum distance the joint will maintain between the two anchors.">cpSlideJointGetMax(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_slide_joint.html#ga115742df8d21e9fd150cd54ab0814daf" title="Set the maximum distance the joint will maintain between the two anchors.">cpSlideJointSetMax(cpConstraint *constraint, cpFloat value)</a></code></li>
</ul>
<h2><a class="anchor" id="autotoc_md75"></a>
Pivot Joints</h2>
<pre class="fragment">&lt;code&gt;cpPivotJoint *cpPivotJointAlloc(void)
cpPivotJoint *cpPivotJointInit(cpPivotJoint *joint, cpBody *a, cpBody *b, cpVect pivot)
cpConstraint *cpPivotJointNew(cpBody *a, cpBody *b, cpVect pivot)
cpConstraint *cpPivotJointNew2(cpBody *a, cpBody *b, cpVect anchorA, cpVect anchorB)&lt;/code&gt;
</pre><p> ::: expl <code>a</code> and <code>b</code> are the two bodies to connect, and <code>pivot</code> is the point in world coordinates of the pivot. Because the pivot location is given in world coordinates, you must have the bodies moved into the correct positions already. Alternatively you can specify the joint based on a pair of anchor points, but make sure you have the bodies in the right place as the joint will fix itself as soon as you start simulating the space. :::</p>
<h3><a class="anchor" id="autotoc_md76"></a>
Properties</h3>
<ul>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> cpPivotJointGetanchorA(const cpConstraint *constraint)</code></li>
<li><code>void cpPivotJointSetanchorA(cpConstraint *constraint, cpVect value)</code></li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> cpPivotJointGetanchorB(const cpConstraint *constraint)</code></li>
<li><code>void cpPivotJointSetanchorB(cpConstraint *constraint, cpVect value)</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md77"></a>
Groove Joint</h2>
<pre class="fragment">&lt;code&gt;cpGrooveJoint *cpGrooveJointAlloc(void)

cpGrooveJoint *cpGrooveJointInit(
    cpGrooveJoint *joint, cpBody *a, cpBody *b,
    cpVect groove_a, cpVect groove_b, cpVect anchorB
)

cpConstraint *cpGrooveJointNew(cpBody *a, cpBody *b, cpVect groove_a, cpVect groove_b, cpVect anchorB)&lt;/code&gt;
</pre><p> ::: expl The groove goes from <code>groov_a</code> to <code>groove_b</code> on body <code>a</code>, and the pivot is attached to <code>anchorB</code> on body <code>b</code>. All coordinates are body local. :::</p>
<h3><a class="anchor" id="autotoc_md78"></a>
Properties</h3>
<ul>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_groove_joint.html#gac1d547a55341236f9659ed31a278b903" title="Get the first endpoint of the groove relative to the first body.">cpGrooveJointGetGrooveA(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_groove_joint.html#gab3d7c3d52caae08d19bd6eadbcad4e2f" title="Set the first endpoint of the groove relative to the first body.">cpGrooveJointSetGrooveA(cpConstraint *constraint, cpVect value)</a></code></li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> <a class="el" href="group__cp_groove_joint.html#gafe3c54f440f638dde48bcc3be3e44cc5" title="Get the first endpoint of the groove relative to the first body.">cpGrooveJointGetGrooveB(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_groove_joint.html#ga56f0b4f7aff4eff68da2f60f1879b846" title="Set the first endpoint of the groove relative to the first body.">cpGrooveJointSetGrooveB(cpConstraint *constraint, cpVect value)</a></code></li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> cpGrooveJointGetanchorB(const cpConstraint *constraint)</code></li>
<li><code>void cpGrooveJointSetanchorB(cpConstraint *constraint, cpVect value)</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md79"></a>
Damped Spring</h2>
<pre class="fragment">&lt;code&gt;cpDampedSpring *cpDampedSpringAlloc(void)

cpDampedSpring *cpDampedSpringInit(
    cpDampedSpring *joint, cpBody *a, cpBody *b, cpVect anchorA, cpVect anchorB,
    cpFloat restLength, cpFloat stiffness, cpFloat damping
)

cpConstraint *cpDampedSpringNew(
    cpBody *a, cpBody *b, cpVect anchorA, cpVect anchorB,
    cpFloat restLength, cpFloat stiffness, cpFloat damping
)&lt;/code&gt;
</pre><p> ::: expl Defined much like a slide joint. <code>restLength</code> is the distance the spring wants to be, <code>stiffness</code> is the spring constant ([Young's modulus](<a href="http://en.wikipedia.org/wiki/Young's_modulus">http://en.wikipedia.org/wiki/Young's_modulus</a>)), and <code>damping</code> is how soft to make the damping of the spring. :::</p>
<h3><a class="anchor" id="autotoc_md80"></a>
Properties</h3>
<ul>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> cpDampedSpringGetanchorA(const cpConstraint *constraint)</code></li>
<li><code>void cpDampedSpringSetanchorA(cpConstraint *constraint, cpVect value)</code></li>
<li><code><a class="el" href="structcp_vect.html">cpVect</a> cpDampedSpringGetanchorB(const cpConstraint *constraint)</code></li>
<li><code>void cpDampedSpringSetanchorB(cpConstraint *constraint, cpVect value)</code></li>
<li><code>cpFloat <a class="el" href="group__cp_damped_spring.html#gaf70dea86936946e0888fb05ff7813b8a" title="Get the rest length of the spring.">cpDampedSpringGetRestLength(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_damped_spring.html#ga4809ef7ab843a29125daca2153a3960e" title="Set the rest length of the spring.">cpDampedSpringSetRestLength(cpConstraint *constraint, cpFloat value)</a></code></li>
<li><code>cpFloat <a class="el" href="group__cp_damped_spring.html#ga4f649481e8d9c0a166e9d9dc26fd1cdc" title="Get the stiffness of the spring in force/distance.">cpDampedSpringGetStiffness(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_damped_spring.html#gafb0a681c3c2ec31001bd55be1080beda" title="Set the stiffness of the spring in force/distance.">cpDampedSpringSetStiffness(cpConstraint *constraint, cpFloat value)</a></code></li>
<li><code>cpFloat <a class="el" href="group__cp_damped_spring.html#gaa97fd3bd3901c0366d12bfc8308213b7" title="Get the damping of the spring.">cpDampedSpringGetDamping(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_damped_spring.html#ga88177eeb62c14005496c38c9b6d8669d" title="Set the damping of the spring.">cpDampedSpringSetDamping(cpConstraint *constraint, cpFloat value)</a></code></li>
</ul>
<h2><a class="anchor" id="autotoc_md81"></a>
Damped Rotary Spring</h2>
<pre class="fragment">&lt;code&gt;cpDampedRotarySpring *cpDampedRotarySpringAlloc(void)

cpDampedRotarySpring *cpDampedRotarySpringInit(
    cpDampedRotarySpring *joint, cpBody *a, cpBody *b,
    cpFloat restAngle, cpFloat stiffness, cpFloat damping
)

cpConstraint *cpDampedRotarySpringNew(cpBody *a, cpBody *b, cpFloat restAngle, cpFloat stiffness, cpFloat damping)&lt;/code&gt;
</pre><p> ::: expl Like a damped spring, but works in an angular fashion. <code>restAngle</code> is the relative angle in radians that the bodies want to have, <code>stiffness</code> and <code>damping</code> work basically the same as on a damped spring. :::</p>
<h3><a class="anchor" id="autotoc_md82"></a>
Properties</h3>
<ul>
<li><code>cpFloat <a class="el" href="group__cp_damped_rotary_spring.html#gad64b790743acc1ee723df5c057821a85" title="Get the rest length of the spring.">cpDampedRotarySpringGetRestAngle(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_damped_rotary_spring.html#gaef8aeefa0f56c4bc8c1b1b526d31bbc5" title="Set the rest length of the spring.">cpDampedRotarySpringSetRestAngle(cpConstraint *constraint, cpFloat value)</a></code></li>
<li><code>cpFloat <a class="el" href="group__cp_damped_rotary_spring.html#ga0bdc853bacf56c54c246daa0fb40be62" title="Get the stiffness of the spring in force/distance.">cpDampedRotarySpringGetStiffness(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_damped_rotary_spring.html#ga2da549aff945710a181b704b3a57a6f3" title="Set the stiffness of the spring in force/distance.">cpDampedRotarySpringSetStiffness(cpConstraint *constraint, cpFloat value)</a></code></li>
<li><code>cpFloat <a class="el" href="group__cp_damped_rotary_spring.html#gaaee99f98580f2b93abb35b5b386e176f" title="Get the damping of the spring.">cpDampedRotarySpringGetDamping(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_damped_rotary_spring.html#gacebcb68e260afa9d2e1739acfdadea1d" title="Set the damping of the spring.">cpDampedRotarySpringSetDamping(cpConstraint *constraint, cpFloat value)</a></code></li>
</ul>
<h2><a class="anchor" id="autotoc_md83"></a>
Rotary Limit Joint</h2>
<pre class="fragment">&lt;code&gt;cpRotaryLimitJoint *cpRotaryLimitJointAlloc(void)
cpRotaryLimitJoint *cpRotaryLimitJointInit(cpRotaryLimitJoint *joint, cpBody *a, cpBody *b, cpFloat min, cpFloat max)
cpConstraint *cpRotaryLimitJointNew(cpBody *a, cpBody *b, cpFloat min, cpFloat max)&lt;/code&gt;
</pre><p> ::: expl Constrains the relative rotations of two bodies. <code>min</code> and <code>max</code> are the angular limits in radians. It is implemented so that it's possible to for the range to be greater than a full revolution. :::</p>
<h3><a class="anchor" id="autotoc_md84"></a>
Properties</h3>
<ul>
<li><code>cpFloat <a class="el" href="group__cp_rotary_limit_joint.html#gaf46e42a44cfd7a7c6cfba362bf805d16" title="Get the minimum distance the joint will maintain between the two anchors.">cpRotaryLimitJointGetMin(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_rotary_limit_joint.html#ga922e77b62755609ab1be093349a3acd0" title="Set the minimum distance the joint will maintain between the two anchors.">cpRotaryLimitJointSetMin(cpConstraint *constraint, cpFloat value)</a></code></li>
<li><code>cpFloat <a class="el" href="group__cp_rotary_limit_joint.html#ga074951df3b5fd56e77b7a657c38b6ce9" title="Get the maximum distance the joint will maintain between the two anchors.">cpRotaryLimitJointGetMax(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_rotary_limit_joint.html#gab4db4abac5ec4a8a66fea4382ab55381" title="Set the maximum distance the joint will maintain between the two anchors.">cpRotaryLimitJointSetMax(cpConstraint *constraint, cpFloat value)</a></code></li>
</ul>
<h2><a class="anchor" id="autotoc_md85"></a>
Ratchet Joint</h2>
<pre class="fragment">&lt;code&gt;cpRatchetJoint *cpRatchetJointAlloc(void);
cpRatchetJoint *cpRatchetJointInit(cpRatchetJoint *joint, cpBody *a, cpBody *b, cpFloat phase, cpFloat ratchet);
cpConstraint *cpRatchetJointNew(cpBody *a, cpBody *b, cpFloat phase, cpFloat ratchet);&lt;/code&gt;
</pre><p> ::: expl Works like a socket wrench. <code>ratchet</code> is the distance between "clicks", <code>phase</code> is the initial offset to use when deciding where the ratchet angles are. :::</p>
<h3><a class="anchor" id="autotoc_md86"></a>
Properties</h3>
<ul>
<li><code>cpFloat <a class="el" href="group__cp_ratchet_joint.html#gafa3aadeeff9c829c323c136b3778e4b5" title="Get the angle of the current ratchet tooth.">cpRatchetJointGetAngle(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_ratchet_joint.html#gaec8e1e9ed802b4e042a2901cb83fa6a8" title="Set the angle of the current ratchet tooth.">cpRatchetJointSetAngle(cpConstraint *constraint, cpFloat value)</a></code></li>
<li><code>cpFloat <a class="el" href="group__cp_ratchet_joint.html#ga7375d4a050643c7ae9c33425ccd5e88c" title="Get the phase offset of the ratchet.">cpRatchetJointGetPhase(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_ratchet_joint.html#ga19d03c89211a4fb3497e1858fa4cc710" title="Get the phase offset of the ratchet.">cpRatchetJointSetPhase(cpConstraint *constraint, cpFloat value)</a></code></li>
<li><code>cpFloat <a class="el" href="group__cp_ratchet_joint.html#ga1b085cf204fe62ce3f75fef90dec7152" title="Get the angular distance of each ratchet.">cpRatchetJointGetRatchet(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_ratchet_joint.html#ga42f49bb4793fd51c9673cfa11bdb4a33" title="Set the angular distance of each ratchet.">cpRatchetJointSetRatchet(cpConstraint *constraint, cpFloat value)</a></code></li>
</ul>
<h2><a class="anchor" id="autotoc_md87"></a>
Gear Joint</h2>
<pre class="fragment">&lt;code&gt;cpGearJoint *cpGearJointAlloc(void);
cpGearJoint *cpGearJointInit(cpGearJoint *joint, cpBody *a, cpBody *b, cpFloat phase, cpFloat ratio);
cpConstraint *cpGearJointNew(cpBody *a, cpBody *b, cpFloat phase, cpFloat ratio);&lt;/code&gt;
</pre><p> ::: expl Keeps the angular velocity ratio of a pair of bodies constant. <code>ratio</code> is always measured in absolute terms. It is currently not possible to set the ratio in relation to a third body's angular velocity. <code>phase</code> is the initial angular offset of the two bodies. :::</p>
<h3><a class="anchor" id="autotoc_md88"></a>
Properties</h3>
<ul>
<li><code>cpFloat <a class="el" href="group__cp_gear_joint.html#ga48c460709467b86a7e3209bfdcfca6a0" title="Get the phase offset of the gears.">cpGearJointGetPhase(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_gear_joint.html#gabdbf2950090d65df36ffff002d6e929d" title="Set the phase offset of the gears.">cpGearJointSetPhase(cpConstraint *constraint, cpFloat value)</a></code></li>
<li><code>cpFloat <a class="el" href="group__cp_gear_joint.html#ga2eedbb00537bc98ec8eea4bf1b3439b6" title="Get the angular distance of each ratchet.">cpGearJointGetRatio(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_gear_joint.html#ga75362fa5be36c30d3006be55b1646b73" title="Set the ratio of a gear joint.">cpGearJointSetRatio(cpConstraint *constraint, cpFloat value)</a></code></li>
</ul>
<h2><a class="anchor" id="autotoc_md89"></a>
Simple Motor</h2>
<pre class="fragment">&lt;code&gt;cpSimpleMotor *cpSimpleMotorAlloc(void);
cpSimpleMotor *cpSimpleMotorInit(cpSimpleMotor *joint, cpBody *a, cpBody *b, cpFloat rate);
cpConstraint *cpSimpleMotorNew(cpBody *a, cpBody *b, cpFloat rate);&lt;/code&gt;
</pre><p> ::: expl Keeps the relative angular velocity of a pair of bodies constant. <code>rate</code> is the desired relative angular velocity. You will usually want to set an force (torque) maximum for motors as otherwise they will be able to apply a nearly infinite torque to keep the bodies moving. :::</p>
<h3><a class="anchor" id="autotoc_md90"></a>
Properties</h3>
<ul>
<li><code>cpFloat <a class="el" href="group__cp_simple_motor.html#gabff92055a8625efe698830a8ee2b1757" title="Get the rate of the motor.">cpSimpleMotorGetRate(const cpConstraint *constraint)</a></code></li>
<li><code>void <a class="el" href="group__cp_simple_motor.html#gaadfe5fd9e818af5dc28929f004092b1b" title="Set the rate of the motor.">cpSimpleMotorSetRate(cpConstraint *constraint, cpFloat value)</a></code></li>
</ul>
<h2><a class="anchor" id="autotoc_md91"></a>
Notes</h2>
<ul>
<li>You can add multiple joints between two bodies, but make sure that they don't fight. Doing so can cause the bodies jitter or spin violently.</li>
</ul>
<h1><a class="anchor" id="autotoc_md92"></a>
Overview of Collision Detection in Chipmunk</h1>
<p>In order to make collision detection in Chipmunk as fast as possible, the process is broken down into several stages. While I've tried to keep it conceptually simple, the implementation can be a bit daunting. Fortunately as a user of the library, you don't need to understand everything about how it works. Though if you are trying to squeeze every bit of performance out of Chipmunk, understanding this section can be helpful.</p>
<h2><a class="anchor" id="autotoc_md93"></a>
Spatial Indexing</h2>
<p>A for loop that checks every object against every other object in the scene would be <em>very</em> slow. So the first stage of the collision detection, commonly called the broadphase, uses a high level spatial algorithm to decide which pairs of objects to check for collisions. Currently, Chipmunk supports two spatial indexes, an axis-aligned bounding box tree and a spatial hash. These spatial indexes are able to quickly identify which pairs of shapes are near each other and should be checked for a collision.</p>
<h2><a class="anchor" id="autotoc_md94"></a>
Fast Collision Filtering</h2>
<p>After the spatial index figures out which pairs of shapes are likely to be near each other, it passes each pair back to the space using a callback to perform some additional filtering on the pairs. Before doing anything else, Chipmunk performs a few quick tests to check if shapes should collide.</p>
<ul>
<li><b>Bounding Box Test:</b> The shapes are not colliding if their bounding boxes are not overlapping. Objects like diagonal line segments can trigger a lot of false positives here, but it's unlikely to be something you should worry about.</li>
<li><b>Category Mask Test:</b> The categories of each shape are bitwise ANDed against the category mask of the other shape. If either result is 0, the shapes do not collide.</li>
<li><b>Group Test:</b> Shapes shouldn't collide with other shapes in the same non-zero group.</li>
</ul>
<h2><a class="anchor" id="autotoc_md95"></a>
Constraint Based Filtering</h2>
<p>After fast collision filtering, Chipmunk checks the list of joints on one of the bodies to see if it has a constraint that attaches it to the other body. If that constraint's <code>collideBodies</code> property is false, the collision will be ignored. This check is often very fast since most scenes don't contain a lot of constraints.</p>
<h2><a class="anchor" id="autotoc_md96"></a>
Primitive Shape to Shape Collision Detection</h2>
<p>The most expensive test is to actually check for overlap based on their geometry. Circle to circle and circle to line collisions are very fast. Segment to segment and poly to poly collisions are handled using the GJK/EPA algorithms, and get more expensive as the number of vertexes increases. Simpler shapes make for faster collisions, and often more important, fewer collision points for the solver to run. Chipmunk uses a small dispatch table to figure out which function to use to check if the shapes overlap.</p>
<p>Without going into too much detail, the GJK algorithm checks the distance between two objects, and the EPA algorithm checks how much they are overlapping. If you give your segment and poly shapes a small radius when creating them, the EPA algorithm can usually be skipped, speeding up the collision detection considerably. The radius should be at least as big as the amount of allowed collision slop.</p>
<h2><a class="anchor" id="autotoc_md97"></a>
Collision Handler Filtering</h2>
<p>After checking if two shapes overlap Chipmunk will look to see if you have defined a collision handler for the collision types of the shapes. This is vital to process collisions events for the gameplay, but also gives you a very flexible way to filter out collisions. The return value of the <code>begin()</code> and <code>preSolve()</code> callbacks determines whether or not the colliding pair of shapes is discarded or not. Returning true will keep the pair, false will discard it. Rejecting a collision from a <code>begin()</code> callback is permanent, rejecting it from the <code>preSolve()</code> only applies to the step it occurred in. If you don't define a handler for the given collision types, Chipmunk will call the space's default handler, which by default is defined to simply accept all collisions.</p>
<p>Wildcard collisions can also return a value, but they are handled in a more complicated way. When you create a collision handler between two specific collision types, it's your responsibility to decide when to call the wildcard handlers and what to do with their return values. Otherwise, the default is to call the wildcard handler for the first type, then the second type, and use a logical AND of their return values as filtering value. See <code>DefaultBegin()</code> in <code>cpSpace.c</code> for more information.</p>
<p>While using callbacks to filter collisions is the most flexible way, keep in mind that by the time your callback is called all the most expensive collision detection has already been done. For simulations with a lot of colliding objects each frame, the time spent finding collisions is small compared to the time spent solving the physics for them so it may not be a big deal. Fast collision filtering should be preferred if possible.</p>
<h1><a class="anchor" id="autotoc_md98"></a>
Collision Callbacks</h1>
<p>A physics library without any events or feedback would not be very useful for games. How would you know when the player bumped into an enemy so that you could take some health points away? How would you know how hard the car hit something so you don't play a loud crash noise when a pebble hits it? What if you need to decide if a collision should be ignored based on specific conditions, like implementing one way platforms? Chipmunk has a number of powerful callback systems that you can use to solve these problems.</p>
<h2><a class="anchor" id="autotoc_md99"></a>
Collision Handlers</h2>
<p>A collision handler is a set of 4 function callbacks for the different collision events that Chipmunk recognizes. The event types are:</p>
<ul>
<li><code>begin()</code>: Two shapes just started touching for the first time this step. Return true from the callback to process the collision normally or false to cause Chipmunk to ignore the collision entirely. If you return false, the <code>preSolve()</code> and <code>postSolve()</code> callbacks will never be run, but you will still receive a separate event when the shapes stop overlapping.</li>
<li><code>preSolve()</code>: Two shapes are touching during this step. Return false from the callback to make Chipmunk ignore the collision this step or true to process it normally. Additionally, you may override collision values using <code><a class="el" href="group__cp_arbiter.html#gab049136b2e62e92adfde8f6422664f71" title="Override the friction coefficient that will be applied to the pair of colliding objects.">cpArbiterSetFriction()</a></code>, <code>cpArbiterSetElasticity()</code> or <code>cpArbiterSetSurfaceVelocity()</code> to provide custom friction, elasticity, or surface velocity values. See <a class="el" href="group__cp_arbiter.html">cpArbiter</a> for more info.</li>
<li><code>postSolve()</code>: Two shapes are touching, and their collision response has been processed. You can retrieve the collision impulse or kinetic energy at this time if you want to use it to calculate sound volumes or damage amounts. See <a class="el" href="group__cp_arbiter.html">cpArbiter</a> for more info.</li>
<li><code>separate()</code>: Two shapes have just stopped touching for the first time this step. To ensure that begin()/separate() are always called in balanced pairs, it will also be called when removing a shape while its in contact with something or when deallocating the space.</li>
</ul>
<p>Collision callbacks are closely associated with <a class="el" href="group__cp_arbiter.html">cpArbiter</a> structs. You should familiarize yourself with those as well.</p>
<p><b>Note:</b> Shapes tagged as sensors (<code>cpShape.sensor == true</code>) never generate collisions that get processed, so collisions between sensors shapes and other shapes will never call the <code>postSolve()</code> callback. They still generate <code>begin()</code>, and <code>separate()</code> callbacks, and the <code>preSolve()</code> callback is also called every frame even though there is no collision response.</p>
<p><b>Note #2:</b> <code>preSolve()</code> callbacks are called before the sleeping algorithm runs. If an object falls asleep, its <code>postSolve()</code> callback won't be called until it's reawoken.</p>
<h2><a class="anchor" id="autotoc_md100"></a>
Collision Handler API</h2>
<pre class="fragment">&lt;code&gt;typedef int (*cpCollisionBeginFunc)(cpArbiter *arb, struct cpSpace *space, cpDataPointer data)
typedef int (*cpCollisionPreSolveFunc)(cpArbiter *arb, cpSpace *space, cpDataPointer data)
typedef void (*cpCollisionPostSolveFunc)(cpArbiter *arb, cpSpace *space, cpDataPointer data)
typedef void (*cpCollisionSeparateFunc)(cpArbiter *arb, cpSpace *space, cpDataPointer data)&lt;/code&gt;
</pre><p> ::: expl Collision handler function types. While all of them take an arbiter, space, and a user data pointer, only the <code>begin()</code> and <code>preSolve()</code> callbacks return a value. See above for more information. ::: </p><pre class="fragment">&lt;code&gt;
struct cpCollisionHandler {
    cpCollisionType typeA, typeB;
    cpCollisionBeginFunc beginFunc;
    cpCollisionPreSolveFunc preSolveFunc;
    cpCollisionPostSolveFunc postSolveFunc;
    cpCollisionSeparateFunc separateFunc;
    cpDataPointer userData;
};
&lt;/code&gt;
</pre><p> ::: expl This collision handler processes collisions between objects of type <code>typeA</code> and <code>typeB</code>. Fill the desired collision callback functions - they are documented above. A user definable context pointer <code>userData</code> is included for your convenience. This pointer is provided as an argument in each callback function. ::: </p><pre class="fragment">&lt;code&gt;cpCollisionHandler *cpSpaceAddCollisionHandler(cpSpace *space, cpCollisionType a, cpCollisionType b)&lt;/code&gt;
</pre><p> ::: expl Add a <code><a class="el" href="structcp_collision_handler.html" title="Struct that holds function callback pointers to configure custom collision handling.">cpCollisionHandler</a></code> for specific collision type pair or return the existing handler for the type pair. Whenever shapes with collision types (<code>cpShape.collision_type</code>) <code>a</code> and <code>b</code> collide, this handler will be used to process the collision events. When a new collision handler is created, the callbacks will all be set to builtin callbacks that perform the default behavior (call the wildcard handlers, and accept all collisions). :::</p>
<p>&lt;%= pop_open_example "PlaySoundOnCollision" %&gt; </p><pre class="fragment">&lt;code&gt;cpCollisionHandler *cpSpaceAddWildcardHandler(cpSpace *space, cpCollisionType type)&lt;/code&gt;
</pre><p> ::: expl Add a wildcard collision handler for given collision type. This handler will be used any time an object with this type collides with another object, regardless of its type. A good example is a projectile that should be destroyed the first time it hits anything. There may be a specific collision handler and two wildcard handlers. It's up to the specific handler to decide if and when to call the wildcard handlers and what to do with their return values. (See <code>cpArbiterCallWildcard*()</code> below) When a new wildcard handler is created, the callbacks will all be set to builtin callbacks that perform the default behavior. (Accept all collisions in <code>begin()</code> and <code>preSolve()</code>, or do nothing for <code>postSolve()</code> and <code>separate()</code>). ::: </p><pre class="fragment">&lt;code&gt;cpCollisionHandler *cpSpaceAddDefaultCollisionHandler(cpSpace *space)&lt;/code&gt;
</pre><p> ::: expl Return a reference to the default collision handler or that is used to process all collisions that don't have a more specific handler. The default behavior for each of the callbacks is to call the wildcard handlers, ANDing their return values together if applicable. :::</p>
<h2><a class="anchor" id="autotoc_md101"></a>
Post-Step Callbacks</h2>
<p>Post-step callbacks are the one place where you can break the rules about adding or removing objects from within a callback. In fact, their primary function is to help you safely remove objects from the space that you wanted to disable or destroy in a collision or query callback.</p>
<p>Post step callbacks are registered as a function and a pointer that is used as a key. You can only register one <code>postStep()</code> callback per key. This prevents you from accidentally removing an object more than once. For instance, say that you get a collision callback between a bullet and object A. You want to destroy both the bullet and object A, so you register a <code>postStep()</code> callback to safely remove them from your game. Then you get a second collision callback between the bullet and object B. You register a <code>postStep()</code> callback to remove object B, and a second <code>postStep()</code> callback to remove the bullet. Because you can only register one callback per key, the <code>postStep()</code> callback for the bullet will only be called once, and you can't accidentally try to remove it twice. </p><pre class="fragment">&lt;code&gt;typedef void (*cpPostStepFunc)(cpSpace *space, void *obj, void *data)&lt;/code&gt;
</pre><p> ::: expl Function type used for <code>postStep()</code> callbacks. <code>space</code> is the space the callback was registered on, <code>obj</code> is the pointer value you supplied as the key, and <code>data</code> is a user definable pointer you can use to pass in as a context value. ::: </p><pre class="fragment">&lt;code&gt;cpBool cpSpaceAddPostStepCallback(cpSpace *space, cpPostStepFunc func, void *key, void *data);&lt;/code&gt;
</pre><p> ::: expl Add <code>func</code> to be called before <code><a class="el" href="group__cp_space.html#gae87c828de2fe3709393ba94046212d80" title="Step the space forward in time by dt.">cpSpaceStep()</a></code> returns. <code>key</code> and <code>data</code> will be passed to your function. Only the first callback registered for any unique value of <code>key</code> will be recorded. It returns <code>cpTrue</code> if the callback is scheduled and <code>cpfalse</code> when the <code>key</code> has already been used. The behavior of adding a <code>postStep()</code> callback from outside of a collision handler or query callback is undefined. :::</p>
<p><b>Note:</b> Post-step callbacks are not run in any particular order. If you need to sequence a number of events, you'll need to put them in a single callback.</p>
<h2><a class="anchor" id="autotoc_md102"></a>
Examples</h2>
<p>See the <a href="examples.html#CollisionCallbacks">callback examples</a> for more information.</p>
<h1><a class="anchor" id="autotoc_md103"></a>
Chipmunk Collision Pairs: &lt;tt&gt;cpArbiter&lt;/tt&gt;</h1>
<p>Chipmunk's <code><a class="el" href="structcp_arbiter.html">cpArbiter</a></code> struct encapsulates a pair of colliding shapes and all of the data about their collision. cpArbiters are created when a collision starts, and persist until those shapes are no longer colliding.</p>
<p>Why are they called arbiters? The short answer is that I kept using the word "arbitrates" to describe the way that collisions were resolved and then I saw that Box2D actually called them arbiters way back in 2006 when I was looking at its solver. An arbiter is like a judge, a person that has authority to settle disputes between two people. It was a fun, fitting name and was shorter to type than CollisionPair which I had been using. It was originally meant to be a private internal structure only, but evolved to be useful from callbacks.</p>
<h2><a class="anchor" id="autotoc_md104"></a>
Memory Management</h2>
<p>You will never need to create or free an arbiter. More importantly, because they are entirely managed by the space you should <b>never</b> store a reference to an arbiter as you don't know when they will be freed or reused. Use them within the callback where they are given to you and then forget about them or copy out the information you need.</p>
<h2><a class="anchor" id="autotoc_md105"></a>
Properties</h2>
<pre class="fragment">&lt;code&gt;cpFloat cpArbiterGetElasticity(const cpArbiter *arb)
void cpArbiterSetElasticity(cpArbiter *arb, cpFloat value)&lt;/code&gt;
</pre><p> ::: expl The calculated elasticity for this collision pair. Setting the value in a <code>preSolve()</code> callback will override the value calculated by the space. The default calculation multiplies the elasticity of the two shapes together. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpArbiterGetFriction(const cpArbiter *arb)
void cpArbiterSetFriction(cpArbiter *arb, cpFloat value)&lt;/code&gt;
</pre><p> ::: expl The calculated friction for this collision pair. Setting the value in a <code>preSolve()</code> callback will override the value calculated by the space. The default calculation multiplies the friction of the two shapes together. ::: </p><pre class="fragment">&lt;code&gt;cpVect cpArbiterGetSurfaceVelocity(const cpArbiter *arb)
void cpArbiterSetSurfaceVelocity(cpArbiter *arb, cpVect value)&lt;/code&gt;
</pre><p> ::: expl The calculated surface velocity for this collision pair. Setting the value in a <code>preSolve()</code> callback will override the value calculated by the space. The default calculation subtracts the surface velocity of the second shape from the first and then projects that onto the tangent of the collision. This is so that only friction is affected by default calculation. Using a custom calculation, you can make something that responds like a pinball bumper, or where the surface velocity is dependent on the location of the contact point. ::: </p><pre class="fragment">&lt;code&gt;cpDataPointer cpArbiterGetUserData(const cpArbiter *arb)
void cpArbiterSetUserData(cpArbiter *arb, cpDataPointer data)&lt;/code&gt;
</pre><p> ::: expl A user definable context pointer. The value will persist until just after the <code>separate()</code> callback is called for the pair. :::</p>
<p><b>NOTE:</b> If you need to clean up this pointer, you should implement the <code>separate()</code> callback to do it. Also be careful when destroying the space as there may be active collisions still. In order to trigger the <code>separate()</code> callbacks and clean up your data, you'll need to remove all the shapes from the space before disposing of it. This is something I'd suggest doing anyway. See ChipmunkDemo.c:ChipmunkDemoFreeSpaceChildren() for an example of how to do it easily. </p><pre class="fragment">&lt;code&gt;int cpArbiterGetCount(const cpArbiter *arb)
cpVect cpArbiterGetNormal(const cpArbiter *arb, int i)
cpVect cpArbiterGetPoint(const cpArbiter *arb, int i)
cpFloat cpArbiterGetDepth(const cpArbiter *arb, int i)&lt;/code&gt;
</pre><p> ::: expl Get the number of contacts tracked by this arbiter or the specific collision point, collision normal or penetration depth of a collision point. For the forseeable future, the maximum number of contacts will be two. ::: </p><pre class="fragment">&lt;code&gt;cpBool cpArbiterIsFirstContact(const cpArbiter *arb)&lt;/code&gt;
</pre><p> ::: expl Returns true if this is the first step the two shapes started touching. This can be useful for sound effects for instance. If its the first frame for a certain collision, check the energy of the collision in a <code>postStep()</code> callbock and use that to determine the volume of a sound effect to play. ::: </p><pre class="fragment">&lt;code&gt;cpBool cpArbiterIsRemoval(const cpArbiter *arb)&lt;/code&gt;
</pre><p> ::: expl Returns <code>cpTrue</code> during a <code>separate()</code> callback if the callback was invoked due to an object removal. ::: </p><pre class="fragment">&lt;code&gt;void cpArbiterGetShapes(const cpArbiter *arb, cpShape **a, cpShape **b)
void cpArbiterGetBodies(const cpArbiter *arb, cpBody **a, cpBody **b)&lt;/code&gt;
</pre><p> ::: expl Get the shapes or bodies in the order that they were defined in the collision handler associated with this arbiter. If you defined the handler as <code>cpSpaceAddCollisionHandler(space, 1, 2, ...)</code>, you you will find that <code>a-&gt;collision_type == 1</code> and <code>b-&gt;collision_type == 2</code>. ::: </p><pre class="fragment">&lt;code&gt;cpBool cpArbiterCallWildcardBeginA(cpArbiter *arb, cpSpace *space)
cpBool cpArbiterCallWildcardBeginB(cpArbiter *arb, cpSpace *space)
cpBool cpArbiterCallWildcardPreSolveA(cpArbiter *arb, cpSpace *space)
cpBool cpArbiterCallWildcardPreSolveB(cpArbiter *arb, cpSpace *space)
void cpArbiterCallWildcardPostSolveA(cpArbiter *arb, cpSpace *space)
void cpArbiterCallWildcardPostSolveB(cpArbiter *arb, cpSpace *space)
void cpArbiterCallWildcardSeparateA(cpArbiter *arb, cpSpace *space)
void cpArbiterCallWildcardSeparateB(cpArbiter *arb, cpSpace *space)&lt;/code&gt;
</pre><p> ::: expl These functions invoke the wildcard handlers for a given collision. For custom collision handlers between specific types or overriding the default handler, you must decide how to invoke the wildcard handlers since it may be important to call the wildcards first, last, or possibly skip them entirely. For the <code>begin()</code> and <code>preSolve()</code> callbacks, you also need to decide what to do with their return values since they may not agree with each other or the specific handler they were called from. Every collision handler is defined for two types, the "A" variants of these functions call the wildcard handler for the first type, and the "B" variants call the handler for the second type. :::</p>
<p>&lt;%= pop_open_example "CollisionCallback" %&gt;</p>
<h2><a class="anchor" id="autotoc_md106"></a>
Contact Point Sets</h2>
<p>Contact point sets make getting contact information simpler. </p><pre class="fragment">&lt;code&gt;cpContactPointSet cpArbiterGetContactPointSet(const cpArbiter *arb)&lt;/code&gt;
</pre><p> ::: expl Get a contact point set struct from an arbiter. :::</p>
<p>You might do something like the following to get and process a contact point set: </p><pre class="fragment">&lt;code&gt;cpContactPointSet set = cpArbiterGetContactPointSet(arbiter);
for(int i=0; i&lt;set.count; i++){
    // get and work with the collision point normal and penetration distance:
    set.points[i].point
    set.points[i].normal
    set.points[i].dist
}&lt;/code&gt;

&lt;code&gt;void cpArbiterSetContactPointSet(cpArbiter *arb, cpContactPointSet *set)&lt;/code&gt;
</pre><p> ::: expl Replace the contact point set of an Arbiter. You cannot change the number of contacts, but can change the location, normal or penetration distance. The "Sticky" demo uses this to allow objects to overlap an extra amount. You could also use it in a Pong style game to modify the normal of the collision based on the x-position of the collision even though the paddle is a flat shape. :::</p>
<h2><a class="anchor" id="autotoc_md107"></a>
Helper Functions</h2>
<pre class="fragment">&lt;code&gt;void cpArbiterGetShapes(cpArbiter *arb, cpShape **a, cpShape **b)
void cpArbiterGetBodies(const cpArbiter *arb, cpBody **a, cpBody **b)&lt;/code&gt;
</pre><p> ::: expl Get the shapes (or their bodies) in the order that they were defined in the collision handler associated with this arbiter. If you defined the handler as <code>cpSpaceAddCollisionHandler(space, 1, 2, ...)</code>, you you will find that <code>a-&gt;collision_type == 1</code> and <code>b-&gt;collision_type == 2</code>. The convenience macro defines and initializes the two shape variables for you. The default collision handler doesn't use collision types so the order is undefined. ::: </p><pre class="fragment">&lt;code&gt;#define CP_ARBITER_GET_SHAPES(arb, a, b) cpShape *a, *b; cpArbiterGetShapes(arb, &amp;a, &amp;b)
#define CP_ARBITER_GET_BODIES(arb, a, b) cpBody *a, *b; cpArbiterGetBodies(arb, &amp;a, &amp;b);&lt;/code&gt;
</pre><p> ::: expl Shortcut macros for defining variables for and retrieving the shapes/bodies for an arbiter. ::: </p><pre class="fragment">&lt;code&gt;cpVect cpArbiterTotalImpulseWithFriction(cpArbiter *arb);
cpVect cpArbiterTotalImpulse(cpArbiter *arb);&lt;/code&gt;
</pre><p> ::: expl Returns the impulse that was applied this step to resolve the collision. These functions should only be called from a <code>postStep()</code> or <code><a class="el" href="group__cp_body.html#ga1946a82f1a256333fae25c818a68b3ab" title="Call func once for each arbiter that is currently active on the body.">cpBodyEachArbiter()</a></code> callback, otherwise the result is undefined. If in doubt which function to use, use <code>cpArbiterTotalImpulseWithFriction()</code>. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpArbiterTotalKE(const cpArbiter *arb);&lt;/code&gt;
</pre><p> ::: expl Calculate the amount of energy lost in a collision including static, but not dynamic friction. This function should only be called from a <code>postSolve()</code>, <code>postStep()</code> or <code><a class="el" href="group__cp_body.html#ga1946a82f1a256333fae25c818a68b3ab" title="Call func once for each arbiter that is currently active on the body.">cpBodyEachArbiter()</a></code> callback. :::</p>
<h1><a class="anchor" id="autotoc_md108"></a>
Queries</h1>
<p>Chipmunk spaces support four kinds of spatial queries, nearest point, segment, shape and fast bounding box queries. Any type can be performed efficiently against an entire space, and point and segment queries can be performed against individual shapes. All types of queries take a collision group and layer that are used to filter matches out using the same rules used for filtering collisions between shapes. See <a class="el" href="group__cp_shape.html">cpShape</a> for more information. If you don't want to filter out any matches, use <code>CP_ALL_LAYERS</code> for the layers and <code>CP_NO_GROUP</code> as the group.</p>
<h2><a class="anchor" id="autotoc_md109"></a>
Nearest Point Queries</h2>
<p>Point queries are useful for things like mouse picking and simple sensors. They allow you to check if there are shapes within a certain distance of a point, find the closest point on a shape to a given point or find the closest shape to a point. </p><pre class="fragment">&lt;code&gt;typedef struct cpPointQueryInfo {
    /// The nearest shape, NULL if no shape was within range.
    const cpShape *shape;
    /// The closest point on the shape's surface. (in world space coordinates)
    cpVect point;
    /// The distance to the point. The distance is negative if the point is inside the shape.
    cpFloat distance;
    /// The gradient of the signed distance function.
    /// The value should be similar to info.p/info.d, but accurate even for very small values of info.d.
    cpVect gradient;
} cpPointQueryInfo;&lt;/code&gt;
</pre><p> ::: expl Nearest point queries return the point on the surface of the shape as well as the distance from the query point to the surface point. ::: </p><pre class="fragment">&lt;code&gt;cpFloat cpShapeNearestPointQuery(cpShape *shape, cpVect p, cpPointQueryInfo *out)&lt;/code&gt;
</pre><p> ::: expl Find the distance from <code>point</code> to <code>shape</code>. If the point is inside of the shape, the distance will be negative and equal to the depth of the point. ::: </p><pre class="fragment">&lt;code&gt;typedef void (*cpSpaceNearestPointQueryFunc)(cpShape *shape, cpFloat distance, cpVect point, void *data);

void cpSpacePointQuery(
    cpSpace *space, cpVect point, cpFloat maxDistance,
    cpShapeFilter filter,
    cpSpaceNearestPointQueryFunc func, void *data
)&lt;/code&gt;
</pre><p> ::: expl Query <code>space</code> at <code>point</code> for shapes within the given distance range. The <code>filter</code> is applied to the query and follows the same rules as the collision detection. <code>func</code> is called for each shape found along with the distance to the closest point on the shape's surface, the distance to that point and the <code>data</code> argument passed to <code>cpSpaceNearestPointQuery()</code>. Sensor shapes are included. If a <code>maxDistance</code> of <code>0.0</code> is used, the point must lie inside a shape. Negative <code>maxDistance</code> is also allowed meaning that the point must be a under a certain depth within a shape to be considered a match. ::: </p><pre class="fragment">&lt;code&gt;cpShape *cpSpacePointQueryNearest(cpSpace *space, cpVect point, cpFloat maxDistance, cpShapeFilter filter, cpPointQueryInfo *out)&lt;/code&gt;
</pre><p> ::: expl Query <code>space</code> at <code>point</code> and return the closest shape within <code>maxDistance</code> units of distance. <code>out</code> is an optional pointer to a <code><a class="el" href="structcp_point_query_info.html" title="Point query info struct.">cpPointQueryInfo</a></code> if you want additional information about the match. :::</p>
<h2><a class="anchor" id="autotoc_md110"></a>
Segment Queries</h2>
<p>Segment queries are like ray casting, but because not all spatial indexes allow processing infinitely long ray queries it is limited to segments. In practice this is still very fast, and you don't need to worry too much about the performance as long as you aren't using extremely long segments for your queries. </p><pre class="fragment">&lt;code&gt;typedef struct cpSegmentQueryInfo {
    /// The shape that was hit, or NULL if no collision occured.
    const cpShape *shape;
    /// The point of impact.
    cpVect point;
    /// The normal of the surface hit.
    cpVect normal;
    /// The normalized distance along the query segment in the range [0, 1].
    cpFloat alpha;
} cpSegmentQueryInfo;&lt;/code&gt;
</pre><p> ::: expl Segment queries return more information than just a simple yes or no, they also return where a shape was hit and its surface normal at the hit point. <code>t</code> is the percentage between the query start and end points. If you need the hit point in world space or the absolute distance from start, see the segment query helper functions farther down. If a segment query starts within a shape it will have <code>t = 0</code> and <code>n = cpvzero</code>. ::: </p><pre class="fragment">&lt;code&gt;cpBool cpShapeSegmentQuery(cpShape *shape, cpVect a, cpVect b, cpFloat radius, cpSegmentQueryInfo *info)&lt;/code&gt;
</pre><p> ::: expl Perform a segment query from <code>a</code> to <code>b</code> with the given <code>radius</code> against a single shape <code>shape</code>. <code>info</code> must be a valid pointer to a <code><a class="el" href="structcp_segment_query_info.html" title="Segment query info struct.">cpSegmentQueryInfo</a></code> structure which will be initialized with the raycast info. ::: </p><pre class="fragment">&lt;code&gt;typedef void (*cpSpaceSegmentQueryFunc)(cpShape *shape, cpFloat t, cpVect n, void *data)

void cpSpaceSegmentQuery(
    cpSpace *space, cpVect start, cpVect end, cpFloat radius,
    cpShapeFilter filter,
    cpSpaceSegmentQueryFunc func, void *data
)&lt;/code&gt;
</pre><p> ::: expl Query <code>space</code> along the line segment from <code>start</code> to <code>end</code> with the given <code>radius</code>. The <code>filter</code> is applied to the query and follows the same rules as the collision detection. <code>func</code> is called with the normalized distance along the line and surface normal for each shape found along with the <code>data</code> argument passed to <code><a class="el" href="group__cp_space.html#ga62eea2b00f5503976ef250a33d4c474a" title="Query the space at a point and call func for each shape found.">cpSpacePointQuery()</a></code>. Sensor shapes are included. ::: </p><pre class="fragment">&lt;code&gt;cpShape *cpSpaceSegmentQueryFirst(
    cpSpace *space, cpVect start, cpVect end, cpFloat radius,
    cpShapeFilter filter,
    cpSegmentQueryInfo *info
)&lt;/code&gt;
</pre><p> ::: expl Query <code>space</code> along the line segment from <code>start</code> to <code>end</code> with the given <code>radius</code>. The <code>filter</code> is applied to the query and follows the same rules as the collision detection. Only the first shape encountered is returned and the search is short circuited. Returns <code>NULL</code> if no shape was found. The info struct pointed to by <code>info</code> will be initialized with the raycast info unless <code>info</code> is NULL. Sensor shapes are ignored. :::</p>
<h2><a class="anchor" id="autotoc_md111"></a>
AABB Queries</h2>
<p>AABB queries give you a fast way to check roughly which shapes are in an area. </p><pre class="fragment">&lt;code&gt;typedef void (*cpSpaceBBQueryFunc)(cpShape *shape, void *data)

void cpSpaceBBQuery(
    cpSpace *space, cpBB bb,
    cpShapeFilter filter,
    cpSpaceBBQueryFunc func, void *data
)&lt;/code&gt;
</pre><p> ::: expl Query <code>space</code> to find all shapes near <code>bb</code>. The <code>filter</code> is applied to the query and follows the same rules as the collision detection. <code>func</code> is called for each shape whose bounding box overlaps <code>bb</code> along with the <code>data</code> argument passed to <code><a class="el" href="group__cp_space.html#ga09e4737a3b33755ee20066297138b64e" title="Perform a fast rectangle query on the space calling func for each shape found.">cpSpaceBBQuery()</a></code>. Sensor shapes are included. :::</p>
<h2><a class="anchor" id="autotoc_md112"></a>
Shape Queries</h2>
<p>Shape queries allow you to check if shapes in a space are overlapping a specific area. You can use this to check if an object already exists at a location you want to add another shape, or to use as sensor queries for AI.</p>
<p>You can either create a body/shape pair before querying, or you can create a shape passing <code>NULL</code> for the body and position the shape using <code><a class="el" href="group__cp_shape.html#gaa3ce1518fb4739b0b4e8964dfb7cd728" title="Update, cache and return the bounding box of a shape with an explicit transformation.">cpShapeUpdate()</a></code> to set the position and rotation of the shape. </p><pre class="fragment">&lt;code&gt;typedef void (*cpSpaceShapeQueryFunc)(cpShape *shape, cpContactPointSet *points, void *data);

cpBool cpSpaceShapeQuery(cpSpace *space, cpShape *shape, cpSpaceShapeQueryFunc func, void *data);&lt;/code&gt;
</pre><p> ::: expl Query <code>space</code> to find all shapes overlapping <code>shape</code>. <code>func</code> is called for each overlapping shape along with a pointer to a temporary <a class="el" href="structcp_contact_point_set.html" title="A struct that wraps up the important collision data for an arbiter.">cpContactPointSet</a> and the <code>data</code> argument passed to <code><a class="el" href="group__cp_space.html#ga09e4737a3b33755ee20066297138b64e" title="Perform a fast rectangle query on the space calling func for each shape found.">cpSpaceBBQuery()</a></code>. Sensor shapes are included. :::</p>
<h2><a class="anchor" id="autotoc_md113"></a>
Blocks</h2>
<p>If your compiler supports blocks (such as Clang), there are an alternate set of functions you can call. <code>cpSpaceNearestPointQuery_b()</code>, etc. See <code><a class="el" href="chipmunk_8h_source.html">chipmunk.h</a></code> for more information.</p>
<h2><a class="anchor" id="autotoc_md114"></a>
Examples</h2>
<p>See the <a href="examples.html#Query">query examples</a> for more information. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jan 28 2025 20:09:53 for Munk2D Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
